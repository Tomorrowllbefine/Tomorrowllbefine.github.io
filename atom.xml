<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>mmkk&#39;s blogs</title>
  
  <subtitle>Stay Hungry,  Stay Foolish.</subtitle>
  <link href="https://tomorrowllbefine.github.io/atom.xml" rel="self"/>
  
  <link href="https://tomorrowllbefine.github.io/"/>
  <updated>2025-01-20T03:54:04.073Z</updated>
  <id>https://tomorrowllbefine.github.io/</id>
  
  <author>
    <name>mmkk</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring核心- | ①Spring BeanFactory详解</title>
    <link href="https://tomorrowllbefine.github.io/2025/01/20/NNxGd8x2Zo2U5ZxoaHrcFFYAnLh/"/>
    <id>https://tomorrowllbefine.github.io/2025/01/20/NNxGd8x2Zo2U5ZxoaHrcFFYAnLh/</id>
    <published>2025-01-20T03:53:53.000Z</published>
    <updated>2025-01-20T03:54:04.073Z</updated>
    
    <content type="html"><![CDATA[<h1 id="【Spring-核心】①Spring-容器和-Bean"><a href="#【Spring-核心】①Spring-容器和-Bean" class="headerlink" title="【Spring 核心】①Spring 容器和 Bean"></a>【Spring 核心】①Spring 容器和 Bean</h1><h1 id="一、Spring-容器"><a href="#一、Spring-容器" class="headerlink" title="一、Spring 容器"></a>一、Spring 容器</h1><h2 id="1-1-BeanFactory"><a href="#1-1-BeanFactory" class="headerlink" title="1.1 BeanFactory"></a>1.1 BeanFactory</h2><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DefaultSingletonBeanRegistry.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultSingletonBeanRegistry</span> <span class="keyword">extends</span> <span class="title class_">SimpleAliasRegistry</span> <span class="keyword">implements</span> <span class="title class_">SingletonBeanRegistry</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>(<span class="number">256</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DefaultSingletonBeanRegistry</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><img src="/static/KzmSbu87KopOxzxzP4LcV3rwnAg.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringBootDemoApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException &#123;</span><br><span class="line">        <span class="comment">// 获取Spring上下文</span></span><br><span class="line">        <span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> SpringApplication._run_(SpringBootDemoApplication.class, args);</span><br><span class="line">        <span class="comment">// 通过反射：获取Spring容器中单例对象集合字段(私有)</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">singletonObjects</span> <span class="operator">=</span> DefaultSingletonBeanRegistry.class.getDeclaredField(<span class="string">&quot;singletonObjects&quot;</span>);</span><br><span class="line">        singletonObjects.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">// 获取容器beanFactory</span></span><br><span class="line">        <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> context.getBeanFactory();</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Object&gt; map = (Map&lt;String, Object&gt;) singletonObjects.get(beanFactory);</span><br><span class="line">        map.entrySet().stream().filter(e -&gt; e.getKey().startsWith(<span class="string">&quot;component&quot;</span>))</span><br><span class="line">                .forEach(e -&gt; &#123;</span><br><span class="line">                    System._out_.println(e.getKey() + <span class="string">&quot; -- &quot;</span> + e.getValue());</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">component1 -- com.example.springbootdemo.service.Bean1@a22c4d8</span><br><span class="line">component2 -- com.example.springbootdemo.service.Bean2@<span class="number">45</span>cd7bc5</span><br></pre></td></tr></table></figure><h2 id="1-2-ApplicationContext"><a href="#1-2-ApplicationContext" class="headerlink" title="1.2 ApplicationContext"></a>1.2 ApplicationContext</h2><hr><p><img src="/static/ANstbu200o9F2Wx7p9GcleFYnob.png"></p><blockquote><p><em>context.getMessage() 方法</em></p></blockquote><p><img src="/static/FL3zbQEhJo23U4xVyzxc5l1EnRf.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// EnvironmentCapable.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EnvironmentCapable</span> &#123;</span><br><span class="line">    Environment <span class="title function_">getEnvironment</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ResourcePatternResolver.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ResourcePatternResolver</span> <span class="keyword">extends</span> <span class="title class_">ResourceLoader</span> &#123;</span><br><span class="line">    String _CLASSPATH_ALL_URL_PREFIX _= <span class="string">&quot;classpath*:&quot;</span>;</span><br><span class="line"></span><br><span class="line">    Resource[] getResources(String locationPattern) <span class="keyword">throws</span> IOException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取类路径下的application.properties文件</span></span><br><span class="line">Resource[] resources = context.getResources(<span class="string">&quot;classpath:application.properties&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">    System._out_.println(resource);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取所有classpath下的spring.factories文件</span></span><br><span class="line">resources = context.getResources(<span class="string">&quot;classpath*:spring.factories&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">    System._out_.println(resource);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取环境变量</span></span><br><span class="line">System._out_.println(context.getEnvironment().getProperty(<span class="string">&quot;java_home&quot;</span>));</span><br><span class="line">System._out_.println(context.getEnvironment().getProperty(<span class="string">&quot;server.port&quot;</span>));</span><br></pre></td></tr></table></figure><p>基于<strong>发布-订阅模式</strong>，通过 <code>ApplicationEvent</code> 和 <code>ApplicationListener</code> 来实现。</p><p>Spring 的事件机制鼓励监听器作为 Spring Bean 注册，但并不是强制性的</p><p><strong>&gt;&gt; 定义事件类，需继承 ApplicationEvent 类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">_<span class="comment">/**_</span></span><br><span class="line"><span class="comment">_ * 基础事件类，用于封装事件源和消息内容。_</span></span><br><span class="line"><span class="comment">_ * _</span></span><br><span class="line"><span class="comment">_ * _**<span class="doctag">@author</span> **_limoukun_</span></span><br><span class="line"><span class="comment">_ * _**<span class="doctag">@since</span> **_2024/12/26_</span></span><br><span class="line"><span class="comment">_ **/</span>_</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BaseEvent</span> <span class="keyword">extends</span> <span class="title class_">ApplicationEvent</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Serial</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> _serialVersionUID _= <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BaseEvent</span><span class="params">(Object source, String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(source);</span><br><span class="line">        <span class="built_in">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>&gt;&gt; 测试调用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发布事件消息  </span></span><br><span class="line"><span class="comment">// **param1: Object - 源bean对象 **</span></span><br><span class="line">context.publishEvent(<span class="keyword">new</span> <span class="title class_">BaseEvent</span>(<span class="string">&quot;null&quot;</span>, <span class="string">&quot;测试事件消息&quot;</span>));</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component(&quot;component1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean1</span> &#123;</span><br><span class="line"></span><br><span class="line">    String value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenBaseEvent</span><span class="params">(BaseEvent event)</span>&#123;</span><br><span class="line">        _log_.info(<span class="string">&quot;Bean1 接收到事件：&#123;&#125;&quot;</span>, event.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><em>监听的方法可以任何一个 bean 中实现；</em></p></blockquote><p><strong>&gt;&gt; 测试结果</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2024</span><span class="number">-12</span><span class="number">-26</span>T11:<span class="number">33</span>:<span class="number">16.840</span><span class="number">+0</span>8:<span class="number">00</span>  INFO <span class="number">24684</span> --- [main] c.example.springbootdemo.service.Bean1   : Bean1 接收到事件：测试事件消息</span><br></pre></td></tr></table></figure><h3 id="Q：对于用户注册和短信发送功能，使用-AOP-实现，比较与事件发布监听模型相比的区别？"><a href="#Q：对于用户注册和短信发送功能，使用-AOP-实现，比较与事件发布监听模型相比的区别？" class="headerlink" title="Q：对于用户注册和短信发送功能，使用 AOP 实现，比较与事件发布监听模型相比的区别？"></a>Q：对于用户注册和短信发送功能，使用 AOP 实现，比较与事件发布监听模型相比的区别？</h3><hr><p>使用 AOP 可以很好地解耦用户注册和短信发送功能，将短信发送的逻辑从注册功能中分离出来，使代码更清晰、更具扩展性。</p><p>分别为两个服务定义对应的实现方法，在切面中调用用户注册逻辑，并为其添加后置通知，在通知中调用短信发送逻辑。<strong>只有在切面中的逻辑执行完成（即用户成功注册），才会在后置通知中调用短信发送逻辑</strong>。</p><p><img src="/static/QaZFbEi5moIsFYxNqcVc4GNfnJe.png"></p><p><strong>AOP 适用场景</strong>：</p><ul><li>简单逻辑：适合在目标方法执行后直接附加一段逻辑，如日志记录、性能监控等；</li><li>代码侵入少：目标方法不需要额外操作，关注点较为单一；</li><li>性能优先：逻辑简单且需要同步执行，可以避免复杂事件模型的开销；</li></ul><p><strong>事件发布-监听模型使用场景</strong>：</p><ul><li>复杂的业务流程：如注册后需要同时发送短信、邮件、写日志等多个操作；</li><li>动态扩展需求：可能在未来添加新的监听器，响应更多事件；</li><li>异步需求：需要监听器进行异步处理，如高并发下的短信、邮件发送业务；</li></ul><h1 id="二、容器实现"><a href="#二、容器实现" class="headerlink" title="二、容器实现"></a>二、容器实现</h1><h2 id="2-1-的实现"><a href="#2-1-的实现" class="headerlink" title="2.1 &lt;&gt; 的实现"></a>2.1 &lt;<BeanFactory>&gt; 的实现</h2><hr><p>BeanFactory 需要手动调用 <strong>BeanFactory 的后置处理器</strong>进行增强</p><ul><li>如通过解析 @Bean、@ComponentScan 等注解，补充了对 bean 的定义；</li></ul><blockquote><p><strong>原始</strong><em>：@Configuration；</em><br><strong>补充</strong>_：@Bean _<em>、@ComponentScan__等；</em></p></blockquote><p><img src="/static/K7ZCbBtQho11lExjXUGctj7RnDe.png"></p><p>BeanFactory 需要手动添加 <strong>Bean 的后置处理器</strong>，以便对后续 Bean 的创建过程提供增强</p><ul><li>如 @AutoWired、@Resource 等注解的解析都是 Bean 后置处理器完成；</li><li>Bean 后处理器的添加顺序会对解析结果有影响；</li></ul><blockquote><p><strong>补充</strong><em>：@AutoWired、@Resource</em></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">_<span class="comment">/**_</span></span><br><span class="line"><span class="comment">_ * 测试 - BeanFactory_</span></span><br><span class="line"><span class="comment">_ *_</span></span><br><span class="line"><span class="comment">_ * _**<span class="doctag">@author</span> **_limoukun_</span></span><br><span class="line"><span class="comment">_ * _**<span class="doctag">@since</span> **_2024/12/26_</span></span><br><span class="line"><span class="comment">_ **/</span>_</span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestBeanFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DefaultListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultListableBeanFactory</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// bean 的定义：class、scope、初始化方式、销毁方式等</span></span><br><span class="line">        <span class="type">AbstractBeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> BeanDefinitionBuilder._genericBeanDefinition_(Config.class)</span><br><span class="line">                .setScope(<span class="string">&quot;singleton&quot;</span>)</span><br><span class="line">                .getBeanDefinition();</span><br><span class="line">        beanFactory.registerBeanDefinition(<span class="string">&quot;config&quot;</span>, beanDefinition);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为 BeanFactory 添加常用的后置处理器</span></span><br><span class="line"><span class="comment">//        AnnotationConfigUtils.registerAnnotationConfigProcessors(beanFactory);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(String beanName : beanFactory.getBeanDefinitionNames())&#123;</span><br><span class="line">            System._out_.println(<span class="string">&quot;beanName - &quot;</span> + beanName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Configuration</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Config</span>&#123;</span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="keyword">public</span> Bean1 <span class="title function_">bean1</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bean1</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="keyword">public</span> Bean2 <span class="title function_">bean2</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bean2</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><blockquote><p>BeanFactory 不会做的事：</p></blockquote></blockquote><ol><li>不会主动调用 BeanFactory 后置处理器；</li><li>不会主动添加 Bean 后处理器；</li><li>不会主动初始化单例；</li><li>不会解析 BeanFactory；</li><li>不会解析 <code>$&#123;&#125;</code> 和 <code>#&#123;&#125;</code>；</li></ol><blockquote><blockquote><p>Bean 的后置处理器有排序逻辑；</p></blockquote></blockquote><p>关于主动初始化单例，BeanFactory 中默认是<strong>懒汉式初始化</strong>，因此如果需要在编译期间就进行初始化，需要主动调用 <code>preInstantiateSingletons()</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (String beanName : beanFactory.getBeanDefinitionNames()) &#123;</span><br><span class="line">    System._out_.println(<span class="string">&quot;beanName - &quot;</span> + beanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开启饿汉式初始化实例</span></span><br><span class="line">beanFactory.preInstantiateSingletons();</span><br><span class="line">System._out_.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 编译期 -&gt; 执行期 &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>);</span><br><span class="line">System._out_.println(beanFactory.getBean(Bean1.class).getBean2());</span><br></pre></td></tr></table></figure><p>输出结果，左-未注释，右-注释：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">beanName - bean1</span><br><span class="line">beanName - bean2</span><br><span class="line"><span class="number">15</span>:<span class="number">57</span>:<span class="number">24.066</span> [main] INFO com.example.springbootdemo.study.beanFactory.TestBeanFactory -- Bean1 构造方法执行</span><br><span class="line"><span class="number">15</span>:<span class="number">57</span>:<span class="number">24.075</span> [main] INFO com.example.springbootdemo.study.beanFactory.TestBeanFactory -- Bean2 构造方法执行</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 编译期 -&gt; 执行期 &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">com.example.springbootdemo.study.beanFactory.TestBeanFactory$Bean2@<span class="number">7</span>c6908d7</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">beanName - bean1</span><br><span class="line">beanName - bean2</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 编译期 -&gt; 执行期 &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line"><span class="number">16</span>:<span class="number">06</span>:<span class="number">34.047</span> [main] INFO com.example.springbootdemo.study.beanFactory.TestBeanFactory -- Bean1 构造方法执行</span><br><span class="line"><span class="number">16</span>:<span class="number">06</span>:<span class="number">34.057</span> [main] INFO com.example.springbootdemo.study.beanFactory.TestBeanFactory -- Bean2 构造方法执行</span><br><span class="line">com.example.springbootdemo.study.beanFactory.TestBeanFactory$Bean2@<span class="number">477</span>b4cdf</span><br></pre></td></tr></table></figure><h2 id="2-2-的实现"><a href="#2-2-的实现" class="headerlink" title="2.2 &lt;&gt; 的实现"></a>2.2 &lt;<ApplicationContext>&gt; 的实现</h2><hr><ol><li>ClassPathXmlApplicationContext；</li><li>FileSystemXmlApplicationContext；</li><li>基于 Java 配置类创建容器，AnnotationConfigApplicationContext；</li></ol><blockquote><ul><li><em>会将带有 @Configuration 注解的类注入，可以在其中配置更多的自定义 Bean；</em></li><li><em>同时，会将前文叙述的 5 个后置处理器类也注入容器；</em></li><li><em>其作用，就是 xml 配置中的</em><em><a href="context:annotation-config/">context:annotation-config&#x2F;</a></em></li></ul></blockquote><ol><li>基于 SpringBoot 中 Servlet Web 环境容器，AnnotationConfigServletWebServerApplicationContext；</li></ol><blockquote><p><em>另外要注意的是，后面这些带有 ApplicationContext 的类都是 ApplicationContext 接口的实现，但它们是</em><strong>组合</strong><em>了 DefaultListableBeanFactory 的功能，并非继承而来</em></p></blockquote><h3 id="Q：关于-context-annotation-config-与-context-component-scan？"><a href="#Q：关于-context-annotation-config-与-context-component-scan？" class="headerlink" title="Q：关于 context:annotation-config&#x2F;与 context:component-scan？"></a>Q：关于 <a href="context:annotation-config/">context:annotation-config&#x2F;</a>与 <a href="context:component-scan">context:component-scan</a>？</h3><hr><blockquote><p><strong>参考好文</strong><em>：</em>_<a href="https://stackoverflow.com/questions/7414794/difference-between-contextannotation-config-and-contextcomponent-scan">https://stackoverflow.com/questions/7414794/difference-between-contextannotation-config-and-contextcomponent-scan</a>_<em>；</em></p></blockquote><p>基础功能，提供对 XML 中自定义 Bean 的注入，同时支持对 Bean 定义注解 @AutoWried 等的处理；</p><p>后者，相对于前者多了对指定包路径的扫描，以达到对指定的 Bean 的注入；</p><p><strong>底层原理</strong>：都是通过添加 BeanFactory 的后置处理器，来实现对除了 @Configuration 以外的 Bean 定义注解的识别、解析和处理；</p><p><strong><a href="context:annotation-config">context:annotation-config</a></strong>** 的作用**</p><ul><li>该标签的主要功能是启用 Spring 的注解驱动功能，例如支持 <code>@Autowired</code>、<code>@Resource</code>、<code>@PostConstruct</code>、<code>@PreDestroy</code> 等注解的处理。</li><li>它并不会扫描包路径，也就是说，<strong>只作用于已经通过 XML 或其他方式显式注册到 Spring 容器中的 Bean</strong>。</li></ul><p><strong><a href="context:component-scan">context:component-scan</a></strong>** 的作用**</p><ul><li>它不仅包含了 <code>&lt;context:annotation-config&gt;</code> 的功能，还额外实现了自动扫描指定包路径下的组件（如 <code>@Component</code>、<code>@Repository</code>、<code>@Service</code>、<code>@Controller</code> 等注解标记的类），并将它们注册为 Spring 容器中的 Bean。</li><li>如果使用了 <code>&lt;context:component-scan&gt;</code>，就不需要单独声明 <code>&lt;context:annotation-config&gt;</code>，因为前者已经隐式地包含了后者的功能。</li></ul><p><strong>底层原理</strong></p><ul><li>两者都依赖于 Spring 的 <code>BeanFactoryPostProcessor</code>，主要通过 <code>ConfigurationClassPostProcessor</code> 来解析相关注解（例如 <code>@Autowired</code>）并将这些注解的元信息存储在容器中。</li><li>对于 <code>&lt;context:component-scan&gt;</code>，还会触发 <code>ClassPathBeanDefinitionScanner</code> 进行包扫描，并根据指定的注解（如 <code>@Component</code>）自动创建 <code>BeanDefinition</code> 并注册到容器。</li></ul><p><strong>总结两者的区别</strong></p><ul><li><code>&lt;context:annotation-config&gt;</code>：启用注解驱动功能，作用于已定义的 Bean。</li><li><code>&lt;context:component-scan&gt;</code>：在启用注解驱动功能的基础上，增加了自动扫描和注册的能力。</li></ul><p>此外，对于如下三个内部类（后置处理器），Spring 会通过 <code>AnnotationConfigUtils</code> 自动注册这三个（以及其他一些内部的 BeanPostProcessor 和 BeanFactoryPostProcessor）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.context.annotation.internalConfigurationAnnotationProcessor</span><br><span class="line">org.springframework.context.annotation.internalAutowiredAnnotationProcessor</span><br><span class="line">org.springframework.context.annotation.internalCommonAnnotationProcessor</span><br></pre></td></tr></table></figure><ul><li>使用 <code>&lt;context:annotation-config&gt;</code> 或 <code>&lt;context:component-scan&gt;</code>，Spring 会自动注册 <strong>internalConfigurationAnnotationProcessor</strong>，从而启用对 <code>@Configuration</code> 和其他相关注解的处理。</li><li>使用 <code>&lt;context:annotation-config&gt;</code> 或 <code>&lt;context:component-scan&gt;</code> 时，Spring 会自动注册 <strong>internalAutowiredAnnotationProcessor</strong>，确保容器中的 Bean 能正确解析 <code>@Autowired</code> 等注解。</li><li>使用 <code>&lt;context:annotation-config&gt;</code> 或 <code>&lt;context:component-scan&gt;</code> 时，Spring 会自动注册 <strong>internalCommonAnnotationProcessor</strong>，确保容器中的 Bean 能正确解析 <code>@Resource</code> 等注解</li></ul><h3 id="2-2-x-AnnotationConfigServletWebServerApplicationContext"><a href="#2-2-x-AnnotationConfigServletWebServerApplicationContext" class="headerlink" title="2.2.x AnnotationConfigServletWebServerApplicationContext"></a>2.2.x AnnotationConfigServletWebServerApplicationContext</h3><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">_<span class="comment">/**_</span></span><br><span class="line"><span class="comment">_ * 测试 - ApplicationContext的基本实现类_</span></span><br><span class="line"><span class="comment">_ *_</span></span><br><span class="line"><span class="comment">_ * _**<span class="doctag">@author</span> **_limoukun_</span></span><br><span class="line"><span class="comment">_ * _**<span class="doctag">@since</span> **_2024/12/27_</span></span><br><span class="line"><span class="comment">_ **/</span>_</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application_01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigServletWebServerApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">AnnotationConfigServletWebServerApplicationContext</span>(WebConfig.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Configuration</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> &#123;</span><br><span class="line">        <span class="comment">// 内嵌Tomcat服务器</span></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="keyword">public</span> ServletWebServerFactory <span class="title function_">servletWebServerFactory</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TomcatServletWebServerFactory</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Dispatcher分发Servlet</span></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="keyword">public</span> DispatcherServlet <span class="title function_">dispatcherServlet</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DispatcherServlet</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绑定 将Dispatcher装载在Tomcat上</span></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="keyword">public</span> DispatcherServletRegistrationBean <span class="title function_">registrationBean</span><span class="params">(DispatcherServlet dispatcherServlet)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DispatcherServletRegistrationBean</span>(dispatcherServlet, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 控制器</span></span><br><span class="line">        <span class="meta">@Bean(&quot;/hello&quot;)</span></span><br><span class="line">        <span class="keyword">public</span> Controller <span class="title function_">controller</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Controller</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> ModelAndView <span class="title function_">handleRequest</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    response.getWriter().println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong>：</p><p><img src="/static/BVsGbIUapoQCcNxjrOicPEcVndg.png"></p><h1 id="三、Bean-生命周期"><a href="#三、Bean-生命周期" class="headerlink" title="三、Bean 生命周期"></a>三、Bean 生命周期</h1><hr><p>根据 Bean 的一些关键节点方法测试生命周期：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application_02</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> SpringApplication._run_(Application_02.class, args);</span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">_<span class="comment">/**_</span></span><br><span class="line"><span class="comment">_ * 测试 - 生命周期Bean_</span></span><br><span class="line"><span class="comment">_ *_</span></span><br><span class="line"><span class="comment">_ * _**<span class="doctag">@author</span> **_limoukun_</span></span><br><span class="line"><span class="comment">_ * _**<span class="doctag">@since</span> **_2024/12/27_</span></span><br><span class="line"><span class="comment">_ **/</span>_</span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LifeCycleBean</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LifeCycleBean</span><span class="params">()</span> &#123;_log_.debug(<span class="string">&quot;构造方法...&quot;</span>);&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 值注入JAVA_HOME</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">autowire</span><span class="params">(<span class="meta">@Value(&quot;$&#123;java_home&#125;&quot;)</span> String home)</span>&#123;</span><br><span class="line">        _log_.debug(<span class="string">&quot;依赖注入:&#123;&#125;&quot;</span>, home);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bean的初始化方法</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">        _log_.debug(<span class="string">&quot;初始化...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bean的销毁方法</span></span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span>&#123;</span><br><span class="line">        _log_.debug(<span class="string">&quot;销毁...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">构造方法...</span><br><span class="line">依赖注入:D:\JAVA8</span><br><span class="line">初始化...</span><br><span class="line"><span class="number">2024</span><span class="number">-12</span><span class="number">-27</span>T20:<span class="number">58</span>:<span class="number">37.423</span><span class="number">+0</span>8:<span class="number">00</span>  INFO <span class="number">17156</span> --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : <span class="function">Tomcat started on <span class="title">port</span><span class="params">(s)</span>: <span class="number">8088</span> (http) with context path <span class="string">&#x27;&#x27;</span></span></span><br><span class="line"><span class="string"><span class="function">2024-12-27T20:58:37.428+08:00  INFO 17156 --- [           main] c.e.s.s.s.Application_02                 : Started Application_02 in 1.177 seconds (process running for 1.649)</span></span></span><br><span class="line"><span class="string"><span class="function">2024-12-27T20:58:37.446+08:00  INFO 17156 --- [           main] o.apache.catalina.core.StandardService   : Stopping service [Tomcat]</span></span></span><br><span class="line"><span class="string"><span class="function">销毁...</span></span></span><br></pre></td></tr></table></figure><p><img src="/static/V7D5bKeofoNxkcxpLEgcH9etnwg.png"><br><img src="/static/J3gZbUqhaouIM9xxj5oc6IXvnMd.png"></p><blockquote><p>_实例化 —— 调用对象的__Ctor()_<em>方法；</em><br>_初始化 —— 调用 Spring Bean 的__init()_<em>方法；</em></p></blockquote><ol><li>对象实例化；</li><li>依赖注入；</li><li>Bean 的初始化；</li><li>Bean 的使用；</li><li>Bean 的销毁；</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2024</span><span class="number">-12</span><span class="number">-28</span>T09:<span class="number">17</span>:<span class="number">52.652</span><span class="number">+0</span>8:<span class="number">00</span> DEBUG <span class="number">28240</span> --- [main] c.e.s.s.s.LifeCycleBean                  : 构造方法...</span><br><span class="line"><span class="number">2024</span><span class="number">-12</span><span class="number">-28</span>T09:<span class="number">17</span>:<span class="number">52.654</span><span class="number">+0</span>8:<span class="number">00</span> DEBUG <span class="number">28240</span> --- [main] c.e.s.s.s.LifeCycleBean                  : 依赖注入:D:\JAVA8</span><br><span class="line"><span class="number">2024</span><span class="number">-12</span><span class="number">-28</span>T09:<span class="number">17</span>:<span class="number">52.655</span><span class="number">+0</span>8:<span class="number">00</span> DEBUG <span class="number">28240</span> --- [main] c.e.s.s.s.LifeCycleBean                  : 初始化...</span><br><span class="line"><span class="number">2024</span><span class="number">-12</span><span class="number">-28</span>T09:<span class="number">17</span>:<span class="number">52.871</span><span class="number">+0</span>8:<span class="number">00</span>  INFO <span class="number">28240</span> --- [main] o.s.b.w.embedded.tomcat.TomcatWebServer  : <span class="function">Tomcat started on <span class="title">port</span><span class="params">(s)</span>: <span class="number">8088</span> (http) with context path <span class="string">&#x27;&#x27;</span></span></span><br><span class="line"><span class="string"><span class="function">2024-12-28T09:17:52.877+08:00  INFO 28240 --- [main] c.e.s.s.s.Application_02                 : Started Application_02 in 1.168 seconds (process running for 1.59)</span></span></span><br><span class="line"><span class="string"><span class="function">2024-12-28T09:17:52.878+08:00 DEBUG 28240 --- [main] c.e.s.s.s.Application_02                 : 使用Bean - com.example.springbootdemo.study.s03_bean_lifecycle.LifeCycleBean@5f95f1e1</span></span></span><br><span class="line"><span class="string"><span class="function">2024-12-28T09:17:52.896+08:00  INFO 28240 --- [main] o.apache.catalina.core.StandardService   : Stopping service [Tomcat]</span></span></span><br><span class="line"><span class="string"><span class="function">2024-12-28T09:17:52.902+08:00 DEBUG 28240 --- [main] c.e.s.s.s.LifeCycleBean                  : 销毁...</span></span></span><br></pre></td></tr></table></figure><blockquote><p><em>后续的扩展点都是基于这</em><strong>基本的 5 步骤</strong><em>进行的追加后置处理器；</em></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 类对象实例化前 postProcessBeforeInstantiation - 后置处理器...</span><br><span class="line">Ctor 构造方法...</span><br><span class="line">&lt;&lt;&lt; 类对象实例化后 postProcessAfterInstantiation - 后置处理器...</span><br><span class="line">+++ 依赖注入阶段 postProcessProperties - 后置处理器，对@Autowired、@Resource等注解解析...</span><br><span class="line">@Autowired 依赖注入:D:\JAVA8</span><br><span class="line">&gt;&gt;&gt; Bean初始化前 postProcessBeforeInitialization - 后置处理器，此处返回的对象会替换原本的Bean...</span><br><span class="line">@PostConstruct 初始化...</span><br><span class="line">+++ Bean初始化后 afterPropertiesSet - 后置处理器...</span><br><span class="line">&lt;&lt;&lt; Bean初始化后 postProcessAfterInitialization - 后置处理器，此处返回的对象会替换原本的Bean，如代理增强...</span><br><span class="line"><span class="function">Tomcat started on <span class="title">port</span><span class="params">(s)</span>: <span class="number">8088</span> (http) with context path <span class="string">&#x27;&#x27;</span></span></span><br><span class="line"><span class="string"><span class="function">Started Application_02 in 1.133 seconds (process running for 1.475)</span></span></span><br><span class="line"><span class="string"><span class="function">使用Bean - com.example.springbootdemo.study.s03_bean_lifecycle.LifeCycleBean@7e72a6cc</span></span></span><br><span class="line"><span class="string"><span class="function">Stopping service [Tomcat]</span></span></span><br><span class="line"><span class="string"><span class="function">@PreDestroy 销毁...</span></span></span><br></pre></td></tr></table></figure><h1 id="四、Bean-后置处理器"><a href="#四、Bean-后置处理器" class="headerlink" title="四、Bean 后置处理器"></a>四、Bean 后置处理器</h1><hr><p>常见的 <code>@Autowired</code> 等注解的解析属于 bean 生命周期阶段（依赖注入、初始化）的扩展功能，这些扩展功能可以由 Bean 后置处理器完成。</p><p>常见的 Bean 后置处理器所增强的功能：</p><ul><li><u>Autowired</u>AnnotationBeanPostProcessor 解析 <code>@Autowired</code> 与 <code>@Value</code>；</li><li><u>Common</u>AnnotationBeanPostProcessor 解析 <code>@Resource</code>、<code>@PostConstruct</code>、<code>@PreDestroy</code>；</li><li><u>ConfigurationProperties</u>BindingPostProcessor 解析 <code>@ConfigurationProperties</code>；</li><li><u>Context</u>AnnotationAutowireCandidateResolver 负责获取 <code>@Value</code> 的值，解析 <code>@Qualifier</code>、泛型、<code>@Lazy</code> 等；</li></ul><h2 id="4-1-Autowired-Bean-后置处理器"><a href="#4-1-Autowired-Bean-后置处理器" class="headerlink" title="4.1 @Autowired Bean 后置处理器"></a>4.1 @Autowired Bean 后置处理器</h2><hr><p>通过<strong>反射</strong>对创建的 <code>AutowiredAnnotationBeanPostProcessor</code> 后置处理器进行调用，分析 @Autowired 的后置处理器的执行原理。</p><p><strong>&gt;&gt; Bean 间的依赖关系</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">Slf4j</span>(topic = <span class="string">&quot;Bean1.java&quot;</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Bean2 bean2;</span><br><span class="line">    <span class="comment">// @Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Bean3 bean3;</span><br><span class="line">    <span class="keyword">private</span> String javaHome;</span><br><span class="line"></span><br><span class="line">    @<span class="function">Autowired</span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="type">void</span> <span class="title">setBean2</span><span class="params">(Bean2 bean2)</span> </span>&#123;</span><br><span class="line">        _log_.<span class="built_in">info</span>(<span class="string">&quot;@Autowired 生效 &#123;&#125;&quot;</span>, bean2);</span><br><span class="line">        <span class="keyword">this</span>.bean2 = bean2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @<span class="function">Resource</span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="type">void</span> <span class="title">setBean3</span><span class="params">(Bean3 bean3)</span> </span>&#123;</span><br><span class="line">        _log_.<span class="built_in">info</span>(<span class="string">&quot;@Resource 生效 &#123;&#125;&quot;</span>, bean3);</span><br><span class="line">        <span class="keyword">this</span>.bean3 = bean3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @<span class="function">Autowired</span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="type">void</span> <span class="title">setJavaHome</span><span class="params">(@Value(<span class="string">&quot;$&#123;java_home&#125;&quot;</span>) String javaHome)</span> </span>&#123;</span><br><span class="line">        _log_.<span class="built_in">info</span>(<span class="string">&quot;@Value 生效 &#123;&#125;&quot;</span>, javaHome);</span><br><span class="line">        <span class="keyword">this</span>.javaHome = javaHome;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @<span class="function">PostConstruct</span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        _log_.<span class="built_in">info</span>(<span class="string">&quot;@PostConstruct 生效&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @<span class="function">PreDestroy</span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="type">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        _log_.<span class="built_in">info</span>(<span class="string">&quot;@PreDestroy 生效&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @<span class="function">Override</span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Bean1&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;bean2=&quot;</span> + bean2 +</span><br><span class="line">                <span class="string">&quot;, bean3=&quot;</span> + bean3 +</span><br><span class="line">                <span class="string">&quot;, javaHome=&#x27;&quot;</span> + javaHome + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>&gt;&gt; 分析和验证 AutowiredAnnotationBeanPostProcessor 执行流程</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">_<span class="comment">/**_</span></span><br><span class="line"><span class="comment">_ * 分析 - AutowiredAnnotationBeanPostProcessor 执行流程_</span></span><br><span class="line"><span class="comment">_ *_</span></span><br><span class="line"><span class="comment">_ * _**<span class="doctag">@author</span> **_limoukun_</span></span><br><span class="line"><span class="comment">_ * _**<span class="doctag">@since</span> **_2024/12/28_</span></span><br><span class="line"><span class="comment">_ **/</span>_</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DigInAutowired</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">DefaultListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultListableBeanFactory</span>();</span><br><span class="line"></span><br><span class="line">        beanFactory.registerSingleton(<span class="string">&quot;bean2&quot;</span>, <span class="keyword">new</span> <span class="title class_">Bean2</span>());</span><br><span class="line">        beanFactory.registerSingleton(<span class="string">&quot;bean3&quot;</span>, <span class="keyword">new</span> <span class="title class_">Bean3</span>());</span><br><span class="line">        processor.setBeanFactory(beanFactory); <span class="comment">// @Value</span></span><br><span class="line">        beanFactory.addEmbeddedValueResolver(<span class="keyword">new</span> <span class="title class_">StandardEnvironment</span>()::resolvePlaceholders); <span class="comment">// $&#123;&#125; 的解析器</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建后置处理器AutowiredAnnotationBeanPostProcessor</span></span><br><span class="line">        <span class="type">AutowiredAnnotationBeanPostProcessor</span> <span class="variable">processor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AutowiredAnnotationBeanPostProcessor</span>();</span><br><span class="line">        processor.setBeanFactory(beanFactory);</span><br><span class="line">        </span><br><span class="line">        <span class="type">Bean1</span> <span class="variable">bean1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bean1</span>();</span><br><span class="line">        System._out_.println(<span class="string">&quot;手动注入@Autowired前:&quot;</span> + bean1);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 通过反射获取AutowiredAnnotationBeanPostProcessor的两个主要方法</span></span><br><span class="line">        <span class="comment">// 获取findAutowiringMetadata()并调用</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">findAutowiringMetadata</span> <span class="operator">=</span> AutowiredAnnotationBeanPostProcessor.class.</span><br><span class="line">                getDeclaredMethod(<span class="string">&quot;findAutowiringMetadata&quot;</span>, String.class, Class.class, PropertyValues.class);</span><br><span class="line">        findAutowiringMetadata.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">InjectionMetadata</span> <span class="variable">injectionMetadata</span> <span class="operator">=</span> (InjectionMetadata) findAutowiringMetadata.invoke(processor, <span class="string">&quot;bean1&quot;</span>, Bean1.class, <span class="literal">null</span>);</span><br><span class="line">        System._out_.println(<span class="string">&quot;injectionMetadata:&quot;</span> + injectionMetadata);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用injectionMetadata.inject()进行注入</span></span><br><span class="line">        injectionMetadata.inject(bean1, <span class="string">&quot;bean1&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">        System._out_.println(<span class="string">&quot;手动注入@Autowired后:&quot;</span> + bean1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>&gt;&gt; 输出结果</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">手动注入@Autowired前:Bean1&#123;bean2=null, bean3=null, javaHome=<span class="string">&#x27;null&#x27;</span>&#125;</span><br><span class="line">injectionMetadata:org.springframework.beans.factory.annotation.InjectionMetadata@<span class="number">442675e1</span></span><br><span class="line"><span class="number">10</span>:<span class="number">18</span>:<span class="number">03.563</span> [main] INFO Bean<span class="number">1.</span>java -- @Autowired 生效 com.example.springbootdemo.study.s04_bean_postprocessor.Bean2@<span class="number">77e9807f</span></span><br><span class="line"><span class="number">10</span>:<span class="number">18</span>:<span class="number">03.571</span> [main] INFO Bean<span class="number">1.</span>java -- @Value 生效 D:\JAVA8</span><br><span class="line">手动注入@Autowired后:Bean1&#123;bean2=com.example.springbootdemo.study.s04_bean_postprocessor.Bean2@<span class="number">77e9807f</span>, bean3=null, javaHome=<span class="string">&#x27;D:\JAVA8&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><p>进入 debug 模式，可以看到 <code>injectionMetadata</code> 中存储了带有 @Autowried 注解的两个 set 方法</p><p><img src="/static/Ilq5b48w6oeP3ZxxBjlcHZOonZe.png"></p><p>前面的例子中，在调用 <code>findAutowiringMetadata()</code> 方法得到了<strong>当前 Bean1 中添加了</strong><strong>@Autowired****注解的属性字段和方法</strong>后，将其都存入了<strong>注入元数据对象</strong> <code>InjectionMetadata</code> 中。</p><p>那么在后续的 <code>inject()</code> 中，核心的逻辑就是<strong>完成对 Bean1 的依赖注入</strong>，就是通过<strong>反射</strong>，将<strong>容器中管理的 Bean</strong> 设置到 Bean1 中<strong>添加了</strong><strong>@Autowired****注解的属性字段和方法。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Bean2 bean2;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Bean3 bean3;</span><br><span class="line">    <span class="keyword">private</span> String javaHome;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBean2</span><span class="params">(Bean2 bean2)</span> &#123;</span><br><span class="line">        _log_.info(<span class="string">&quot;@Autowired 生效 &#123;&#125;&quot;</span>, bean2);</span><br><span class="line">        <span class="built_in">this</span>.bean2 = bean2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBean3</span><span class="params">(Bean3 bean3)</span> &#123;</span><br><span class="line">        _log_.info(<span class="string">&quot;@Resource 生效 &#123;&#125;&quot;</span>, bean3);</span><br><span class="line">        <span class="built_in">this</span>.bean3 = bean3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setJavaHome</span><span class="params">(<span class="meta">@Value(&quot;$&#123;java_home&#125;&quot;)</span> String javaHome)</span> &#123;</span><br><span class="line">        _log_.info(<span class="string">&quot;@Value 生效 &#123;&#125;&quot;</span>, javaHome);</span><br><span class="line">        <span class="built_in">this</span>.javaHome = javaHome;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据上述 Bean1.java 的类定义，可归纳出如下过程图：</p><p><img src="/static/EUk6b67msoXjouxP798ctj2Bn2c.png"></p><p>对上述过程进行模拟：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在得到了injectionMetadata下，如何按照注入Bean的类型查找值？</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">bean3</span> <span class="operator">=</span> Bean1.class.getDeclaredField(<span class="string">&quot;bean3&quot;</span>);</span><br><span class="line"><span class="type">DependencyDescriptor</span> <span class="variable">dd1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DependencyDescriptor</span>(bean3, <span class="literal">false</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">get_bean3</span> <span class="operator">=</span> beanFactory.doResolveDependency(dd1, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">System._out_.println(<span class="string">&quot;Bean3: &quot;</span> + get_bean3);</span><br><span class="line"></span><br><span class="line"><span class="type">Method</span> <span class="variable">setBean2</span> <span class="operator">=</span> Bean1.class.getDeclaredMethod(<span class="string">&quot;setBean2&quot;</span>, Bean2.class);</span><br><span class="line"><span class="type">DependencyDescriptor</span> <span class="variable">dd2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DependencyDescriptor</span>(<span class="keyword">new</span> <span class="title class_">MethodParameter</span>(setBean2, <span class="number">0</span>), <span class="literal">false</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">get_setBean2</span> <span class="operator">=</span> beanFactory.doResolveDependency(dd2, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">System._out_.println(<span class="string">&quot;Bean2: &quot;</span> + get_setBean2);</span><br><span class="line"></span><br><span class="line"><span class="type">Method</span> <span class="variable">setJavaHome</span> <span class="operator">=</span> Bean1.class.getDeclaredMethod(<span class="string">&quot;setJavaHome&quot;</span>, String.class);</span><br><span class="line"><span class="type">DependencyDescriptor</span> <span class="variable">dd3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DependencyDescriptor</span>(<span class="keyword">new</span> <span class="title class_">MethodParameter</span>(setJavaHome, <span class="number">0</span>), <span class="literal">false</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">get_setJavaHome</span> <span class="operator">=</span> beanFactory.doResolveDependency(dd3, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">System._out_.println(<span class="string">&quot;Value(\&quot;$&#123;java_home&#125;\&quot;): &quot;</span> + get_setJavaHome);</span><br></pre></td></tr></table></figure><p><strong>分析</strong>：</p><ol><li><p><strong>通过 <strong><strong>DependencyDescriptor</strong></strong> 描述注入点：</strong><code>DependencyDescriptor</code> 是 Spring 用于描述依赖注入点的对象，可以是字段、方法参数等；</p></li><li><p><strong>通过 <strong><strong>doResolveDependency()</strong></strong> 解析依赖</strong>：<code>doResolveDependency</code> 是 <code>DefaultListableBeanFactory</code> 提供的方法，用于根据 <code>DependencyDescriptor</code> 和容器上下文信息解析依赖；</p><ol><li>检查容器中是否有符合类型的 Bean；</li><li>如果注入点上有值注解（如 <code>@Value</code>），解析占位符或默认值；</li><li>根据依赖类型、名称或限定符（<code>@Qualifier</code>）选择合适的依赖；</li></ol></li></ol><p><strong>注意</strong>：</p><ul><li>如果注入的依赖找不到，会根据 <code>DependencyDescriptor</code> 的 <code>required</code> 参数决定是否抛出异常；</li><li>如果依赖有多个候选 Bean，可以通过 <code>@Qualifier</code> 或其他限定符明确指定；</li><li>对于占位符解析，需确保 Spring 的 <code>PropertySourcesPlaceholderConfigurer</code> 正常工作；</li></ul><blockquote><p><em>在 Spring 中，__InjectionMetadata.inject()</em>_ 方法的实际作用是 <em><strong>对某个对象执行依赖注入操作</strong><em>，包括字段注入、方法注入等，通常用于实现 <strong>@Autowired__、</strong>@Value</em></em> 和 <strong>@Resource</strong> 等注解的依赖注入逻辑。_</p><p><strong>作用详解</strong><em>：</em></p><ol><li><strong>注入对象中的依赖</strong><ol><li><em>InjectionMetadata.inject()</em>_ 会按照 <strong>InjectionMetadata</strong> 中保存的注入元数据，逐一对目标对象的字段和方法执行依赖注入。_</li><li><em>该方法通常会通过反射（__ReflectionUtils__）来设置字段值或调用方法。</em></li></ol></li><li><strong>依赖注入的核心逻辑</strong><ol><li><em>解析哪些字段或方法需要注入（通过 <strong>InjectionMetadata</strong> 的元数据）。</em></li><li><em>对这些字段或方法执行依赖注入，将 Spring 容器中管理的 Bean 注入到目标对象中。</em></li></ol></li><li><strong>触发时机</strong><ol><li><em>Spring 框架在 Bean 的生命周期中（通常在初始化阶段）调用该方法，比如通过 <strong>AutowiredAnnotationBeanPostProcessor</strong> 或类似的 <strong>BeanPostProcessor</strong> 实现，执行注入逻辑。</em></li></ol></li></ol></blockquote><h3 id="Q：registerSingleton-与-registerBean-的区别？生命周期？"><a href="#Q：registerSingleton-与-registerBean-的区别？生命周期？" class="headerlink" title="Q：registerSingleton() 与 registerBean() 的区别？生命周期？"></a>Q：registerSingleton() 与 registerBean() 的区别？生命周期？</h3><hr><p><code>beanFactory.registerSingleton()</code> 和 <code>registerBean()</code> 是 Spring 框架中用于动态注册 Bean 的两种不同方式，它们的应用场景和实现方式有所不同。</p><p>直接向容器注册一个已经实例化的单例对象，适用于需要直接将一个现有的对象（如某个类的实例、外部创建的对象）注册到 Spring 容器中时使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> applicationContext.getBeanFactory();</span><br><span class="line"><span class="type">MyBean</span> <span class="variable">myBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyBean</span>(); <span class="comment">// 手动创建对象</span></span><br><span class="line">beanFactory.registerSingleton(<span class="string">&quot;myBean&quot;</span>, myBean);</span><br></pre></td></tr></table></figure><p><strong>特点</strong>：</p><ul><li>不会经历 Spring Bean 的完整生命周期；</li><li>不需要容器参与创建，直接注入现成的对象；</li><li>无法注入原型作用域的 Bean，该方法仅支持单例 Bean；</li></ul><p>注册一个新的 Bean 定义，Spring 容器会根据定义自动创建 Bean 实例，需要使用 Spring 提供的 <code>GenericApplicationContext</code> 类。</p><p>用于动态定义和注册 Bean，当需要完全交给 Spring 管理（包括生命周期和依赖注入）时使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">context.registerBean(MyBean.class, () -&gt; <span class="keyword">new</span> <span class="title class_">MyBean</span>(<span class="string">&quot;参数1&quot;</span>, <span class="string">&quot;参数2&quot;</span>)); <span class="comment">// 使用 Supplier 创建</span></span><br><span class="line">context.refresh();</span><br><span class="line"></span><br><span class="line"><span class="type">MyBean</span> <span class="variable">myBean</span> <span class="operator">=</span> context.getBean(MyBean.class);</span><br></pre></td></tr></table></figure><p><strong>特点</strong>：</p><ul><li>支持所有 Bean 作用域（单例、原型等）。</li><li>支持 Spring Bean 生命周期管理（包括初始化、销毁回调）。</li><li>需要先定义 Bean，再交给 Spring 容器实例化。</li></ul><p><img src="/static/OWQ6b3GiioBPdBxEvokcsF9WnPh.png"></p><h3 id="Q：如何处理-registerSingleton-注入的-Bean-中包含有对其它-Bean-的依赖？"><a href="#Q：如何处理-registerSingleton-注入的-Bean-中包含有对其它-Bean-的依赖？" class="headerlink" title="Q：如何处理 registerSingleton()注入的 Bean 中包含有对其它 Bean 的依赖？"></a>Q：如何处理 registerSingleton()注入的 Bean 中包含有对其它 Bean 的依赖？</h3><hr><p>如果使用 <code>beanFactory.registerSingleton()</code> 手动注册了一个 <code>Bean1</code> 实例，而这个实例中有对其他 Bean（如 <code>Bean3</code>）的依赖，Spring 容器 <strong>不会自动解析和注入</strong> <code>Bean3</code>，因为 <code>registerSingleton</code> 注册的对象是已经实例化的对象，Spring 不会重新对其依赖进行注入。</p><p>解决：</p><p>在注册 <code>Bean1</code> 前，手动从容器中获取 <code>Bean3</code> 并注入到 <code>Bean1</code> 中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> applicationContext.getBeanFactory();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手动创建 Bean1 并注入依赖</span></span><br><span class="line"><span class="type">Bean1</span> <span class="variable">bean1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bean1</span>();</span><br><span class="line"><span class="type">Bean3</span> <span class="variable">bean3</span> <span class="operator">=</span> applicationContext.getBean(Bean3.class);</span><br><span class="line">bean1.setBean3(bean3); <span class="comment">// 假设 Bean1 提供了 set 方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册 Bean1</span></span><br><span class="line">beanFactory.registerSingleton(<span class="string">&quot;bean1&quot;</span>, bean1);</span><br></pre></td></tr></table></figure><p>让 <code>Bean1</code> 支持依赖注入，即使通过 <code>new</code> 创建，也能注入依赖。需要开启 Spring 的 AspectJ 支持：</p><ul><li>在配置类中启用 <code>@EnableSpringConfigured</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSpringConfigured</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>为 <code>Bean1</code> 添加 <code>@Configurable</code> 注解</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configurable</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean1</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Bean3 bean3;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getter/setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在实例化 <code>Bean1</code> 时，即使用 <code>new</code> 创建，Spring 也会为其注入 <code>Bean3</code></li></ul><h2 id="4-2-Resource-Bean-后置处理器"><a href="#4-2-Resource-Bean-后置处理器" class="headerlink" title="4.2 @Resource Bean 后置处理器"></a>4.2 @Resource Bean 后置处理器</h2><hr><h1 id="五、Bean-工厂后置处理器"><a href="#五、Bean-工厂后置处理器" class="headerlink" title="五、Bean 工厂后置处理器"></a>五、Bean 工厂后置处理器</h1><hr><p>使用 **GenericApplicationContext **上下文，可以得到较为纯净的 Spring 容器，其中没有添加其它的后置处理器。</p><p>进行如下验证：</p><ul><li>注册 ConfigurationClassPostProcessor 后置处理器，用以处理**@ComponentScan**** <strong><strong>@Bean</strong></strong> <strong><strong>@Import</strong></strong> ****@ImportResource**注解的解析；</li><li>注册 ComponentScanner 后置处理器，用以处理**@Mapper**注解的解析；</li></ul><p><img src="/static/GMaJbIGJ1ozGk6xIOCtchgINnnf.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.example.springbootdemo.study.s05_beanfactory_postprocessor.component&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Config</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Bean1 <span class="title function_">bean1</span><span class="params">()</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bean1</span>();&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactoryBean <span class="title function_">sqlSessionFactoryBean</span><span class="params">(DataSource dataSource)</span> &#123;</span><br><span class="line">        <span class="type">SqlSessionFactoryBean</span> <span class="variable">sqlSessionFactoryBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBean</span>();</span><br><span class="line">        sqlSessionFactoryBean.setDataSource(dataSource);</span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactoryBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(initMethod = &quot;init&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DruidDataSource <span class="title function_">druidDataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">druidDataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        druidDataSource.setUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>);</span><br><span class="line">        druidDataSource.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        druidDataSource.setPassword(<span class="string">&quot;20151109Lmk&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> druidDataSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application_04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line"></span><br><span class="line">        context.registerBean(<span class="string">&quot;config&quot;</span>, Config.class);</span><br><span class="line">        **<span class="comment">// @ComponentScan @Bean @Import @ImportResource**</span></span><br><span class="line">        context.registerBean(ConfigurationClassPostProcessor.class);</span><br><span class="line">        **<span class="comment">// @MapperScanner**</span></span><br><span class="line">        context.registerBean(MapperScannerConfigurer.class, bd -&gt; &#123;</span><br><span class="line">            bd.getPropertyValues().add(<span class="string">&quot;basePackage&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;com.example.springbootdemo.study.s05_beanfactory_postprocessor.mapper&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化容器</span></span><br><span class="line">        context.refresh();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String name : context.getBeanDefinitionNames()) &#123;</span><br><span class="line">            System._out_.println(<span class="string">&quot;beanName - &quot;</span> + name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12</span>:<span class="number">17</span>:<span class="number">55.664</span> [main] INFO com.alibaba.druid.pool.DruidDataSource -- &#123;dataSource<span class="number">-1</span>&#125; inited</span><br><span class="line"><span class="number">12</span>:<span class="number">17</span>:<span class="number">55.711</span> [main] INFO com.example.springbootdemo.study.s05_beanfactory_postprocessor.component.Bean2 -- Bean2 被Spring管理</span><br><span class="line"><span class="number">12</span>:<span class="number">17</span>:<span class="number">55.711</span> [main] INFO com.example.springbootdemo.study.s05_beanfactory_postprocessor.Bean1 -- Bean1 被Spring管理</span><br><span class="line">beanName - config</span><br><span class="line">beanName - org.mybatis.spring.mapper.MapperScannerConfigurer</span><br><span class="line">beanName - mapper1</span><br><span class="line">beanName - mapper2</span><br><span class="line">beanName - org.springframework.context.annotation.internalConfigurationAnnotationProcessor</span><br><span class="line">beanName - org.springframework.context.annotation.internalAutowiredAnnotationProcessor</span><br><span class="line">beanName - org.springframework.context.annotation.internalCommonAnnotationProcessor</span><br><span class="line">beanName - org.springframework.context.event.internalEventListenerProcessor</span><br><span class="line">beanName - org.springframework.context.event.internalEventListenerFactory</span><br><span class="line">beanName - bean2</span><br><span class="line">beanName - bean1</span><br><span class="line">beanName - sqlSessionFactoryBean</span><br><span class="line">beanName - druidDataSource</span><br><span class="line"><span class="number">12</span>:<span class="number">17</span>:<span class="number">55.733</span> [main] INFO com.alibaba.druid.pool.DruidDataSource -- &#123;dataSource<span class="number">-1</span>&#125; closing ...</span><br><span class="line"><span class="number">12</span>:<span class="number">17</span>:<span class="number">55.734</span> [main] INFO com.alibaba.druid.pool.DruidDataSource -- &#123;dataSource<span class="number">-1</span>&#125; closed</span><br></pre></td></tr></table></figure><h3 id="Q：关于只注册了-MapperScannerConfigurer-后置处理器后与还注册了-ConfigurationClassPostProcessor-后置处理器结果一致的思考？"><a href="#Q：关于只注册了-MapperScannerConfigurer-后置处理器后与还注册了-ConfigurationClassPostProcessor-后置处理器结果一致的思考？" class="headerlink" title="Q：关于只注册了 MapperScannerConfigurer 后置处理器后与还注册了 ConfigurationClassPostProcessor 后置处理器结果一致的思考？"></a><strong>Q：关于只注册了 MapperScannerConfigurer 后置处理器后与还注册了 ConfigurationClassPostProcessor 后置处理器结果一致的思考？</strong></h3><hr><p>注册 <code>MapperScannerConfigurer</code> 时，由于它实现了 <code>BeanDefinitionRegistryPostProcessor</code>，会触发 Spring 容器的后置处理器加载流程。</p><p>因此 <code>ConfigurationClassPostProcessor</code> 作为核心组件被加载，间接导致了上述内部 Bean 的注册。</p><p>这些 Bean 是 Spring 容器的标准组件，确保依赖注入、事件监听等核心功能的正常运行。</p><h2 id="5-1-模拟-ConfigurationClassPostProcessor-ComponentScan-组件扫描"><a href="#5-1-模拟-ConfigurationClassPostProcessor-ComponentScan-组件扫描" class="headerlink" title="5.1 模拟 ConfigurationClassPostProcessor - @ComponentScan 组件扫描"></a>5.1 模拟 ConfigurationClassPostProcessor - @ComponentScan 组件扫描</h2><hr><blockquote><p><em>深入理解 ConfigurationClassPostProcessor，拆解核心的关于组件扫描的逻辑，模拟实现。</em></p></blockquote><p><strong>核心逻辑：</strong>通过 ComponentScan 中提供的包路径，找到对应的所有类，检查其中涵盖的类是否有 @Component 注解及其派生注解（如 @Controller）等，若有则将该类封装为 BeanDefinition，注册入 Spring 容器。</p><p><img src="/static/Z4FDbzrRHouBBix6g77c3qkfnuf.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ComponentScan</span> <span class="variable">componentScan</span> <span class="operator">=</span> AnnotationUtils._findAnnotation_(Config.class, ComponentScan.class);</span><br><span class="line"><span class="keyword">if</span>(<span class="literal">null</span> != componentScan)&#123;</span><br><span class="line">    <span class="comment">// 遍历ComponentScan注解上的基础包路径</span></span><br><span class="line">    <span class="keyword">for</span> (String basePackage : componentScan.basePackages()) &#123;</span><br><span class="line">        System._out_.println(<span class="string">&quot;basePackage - &quot;</span> + basePackage);</span><br><span class="line">        <span class="comment">// 转为类文件路径</span></span><br><span class="line">        <span class="comment">// com.example.springbootdemo.study.s05_beanfactory_postprocessor.component</span></span><br><span class="line">        <span class="comment">// -&gt; classpath*:com/example/springbootdemo/study/s05_beanfactory_postprocessor/component/**/*.class</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;classpath*:&quot;</span> + basePackage.replace(<span class="string">&quot;.&quot;</span>, <span class="string">&quot;/&quot;</span>) + <span class="string">&quot;/**/*.class&quot;</span>;</span><br><span class="line">        System._out_.println(<span class="string">&quot;path - &quot;</span> + path);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 工厂 - 缓存和读取 Java 类元数据的类，避免重复加载和解析相同的类信息</span></span><br><span class="line">        <span class="type">CachingMetadataReaderFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CachingMetadataReaderFactory</span>();</span><br><span class="line">        <span class="comment">// 工具类 - BeanName生成器</span></span><br><span class="line">        <span class="type">AnnotationBeanNameGenerator</span> <span class="variable">generator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationBeanNameGenerator</span>();</span><br><span class="line">        Resource[] resources = context.getResources(path);</span><br><span class="line">        <span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">            System._out_.println(resource);</span><br><span class="line">            <span class="type">MetadataReader</span> <span class="variable">metadataReader</span> <span class="operator">=</span> factory.getMetadataReader(resource);</span><br><span class="line">            System._out_.println(<span class="string">&quot;类名: &quot;</span> + metadataReader.getClassMetadata().getClassName());</span><br><span class="line">            <span class="type">AnnotationMetadata</span> <span class="variable">annotationMetadata</span> <span class="operator">=</span> metadataReader.getAnnotationMetadata();</span><br><span class="line">            System._out_.println(<span class="string">&quot;是否加了@Component: &quot;</span> + annotationMetadata.hasAnnotation(Component.class.getName()));</span><br><span class="line">            System._out_.println(<span class="string">&quot;是否加了@Component派生注解: &quot;</span> + annotationMetadata.hasMetaAnnotation(Component.class.getName()));</span><br><span class="line"></span><br><span class="line">            **<span class="comment">// 有@Component注解及其派生注解（如@Controller）等，注入Spring容器**</span></span><br><span class="line">            <span class="keyword">if</span> (annotationMetadata.hasAnnotation(Component.class.getName())</span><br><span class="line">            || annotationMetadata.hasMetaAnnotation(Component.class.getName())) &#123;</span><br><span class="line">                <span class="type">AbstractBeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> BeanDefinitionBuilder</span><br><span class="line">                        ._genericBeanDefinition_(metadataReader.getClassMetadata().getClassName())</span><br><span class="line">                        .getBeanDefinition();</span><br><span class="line"></span><br><span class="line">                <span class="type">DefaultListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> context.getDefaultListableBeanFactory();</span><br><span class="line">                <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> generator.generateBeanName(beanDefinition, beanFactory);</span><br><span class="line">                beanFactory.registerBeanDefinition(beanName, beanDefinition);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">basePackage - com.example.springbootdemo.study.s05_beanfactory_postprocessor.component</span><br><span class="line">path - classpath*:com/example/springbootdemo/study/s05_beanfactory_postprocessor/component<span class="comment">/**/</span>*.<span class="keyword">class</span></span><br><span class="line"><span class="title class_">file</span> [D:\JAVA\workSpace\springBootDemo\target\classes\com\example\springbootdemo\study\s05_beanfactory_postprocessor\component\Bean<span class="number">2.</span><span class="keyword">class</span>]</span><br><span class="line">类名: com.example.springbootdemo.study.s05_beanfactory_postprocessor.component.Bean2</span><br><span class="line">是否加了@Component: <span class="literal">true</span></span><br><span class="line">是否加了@Component派生注解: <span class="literal">false</span></span><br><span class="line">file [D:\JAVA\workSpace\springBootDemo\target\classes\com\example\springbootdemo\study\s05_beanfactory_postprocessor\component\Bean<span class="number">3.</span><span class="keyword">class</span>]</span><br><span class="line">类名: com.example.springbootdemo.study.s05_beanfactory_postprocessor.component.Bean3</span><br><span class="line">是否加了@Component: <span class="literal">true</span></span><br><span class="line">是否加了@Component派生注解: <span class="literal">false</span></span><br><span class="line">file [D:\JAVA\workSpace\springBootDemo\target\classes\com\example\springbootdemo\study\s05_beanfactory_postprocessor\component\Bean<span class="number">4.</span><span class="keyword">class</span>]</span><br><span class="line">类名: com.example.springbootdemo.study.s05_beanfactory_postprocessor.component.Bean4</span><br><span class="line">是否加了@Component: <span class="literal">false</span></span><br><span class="line">是否加了@Component派生注解: <span class="literal">false</span></span><br><span class="line"><span class="number">18</span>:<span class="number">51</span>:<span class="number">50.805</span> [main] INFO com.example.springbootdemo.study.s05_beanfactory_postprocessor.component.Bean2 -- Bean2 被Spring管理</span><br><span class="line"><span class="number">18</span>:<span class="number">51</span>:<span class="number">50.808</span> [main] INFO com.example.springbootdemo.study.s05_beanfactory_postprocessor.component.Bean3 -- Bean3 被Spring管理</span><br><span class="line">-----------------------------------</span><br><span class="line">beanName - config</span><br><span class="line">beanName - bean2</span><br><span class="line">beanName - bean3</span><br></pre></td></tr></table></figure><p>需要<strong>实现 BeanFactoryPostProcessor 接口</strong>，重写其中的 postProcessBeanFactory 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">_<span class="comment">/**_</span></span><br><span class="line"><span class="comment">_ * __BeanFactory后置处理器 - 自定义ComponentScan后置处理器_</span></span><br><span class="line"><span class="comment">_ * func - 扫描Config类上的<span class="doctag">@ComponentScan</span>注解所指定包路径下的所有带有<span class="doctag">@Component</span>注解的Bean并完成注入_</span></span><br><span class="line"><span class="comment">_ *_</span></span><br><span class="line"><span class="comment">_ * _**<span class="doctag">@author</span> **_limoukun_</span></span><br><span class="line"><span class="comment">_ * _**<span class="doctag">@since</span> **_2025/1/2_</span></span><br><span class="line"><span class="comment">_ **/</span>_</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ComponentScanPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanFactoryPostProcessor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory configurableListableBeanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ComponentScan</span> <span class="variable">componentScan</span> <span class="operator">=</span> AnnotationUtils._findAnnotation_(Config.class, ComponentScan.class);</span><br><span class="line">            <span class="keyword">if</span>(<span class="literal">null</span> != componentScan)&#123;</span><br><span class="line">                <span class="comment">// 遍历ComponentScan注解上的基础包路径</span></span><br><span class="line">                <span class="keyword">for</span> (String basePackage : componentScan.basePackages()) &#123;</span><br><span class="line">                    System._out_.println(<span class="string">&quot;basePackage - &quot;</span> + basePackage);</span><br><span class="line">                    <span class="comment">// 转为类文件路径</span></span><br><span class="line">                    <span class="comment">// com.example.springbootdemo.study.s05_beanfactory_postprocessor.component</span></span><br><span class="line">                    <span class="comment">// -&gt; classpath*:com/example/springbootdemo/study/s05_beanfactory_postprocessor/component/**/*.class</span></span><br><span class="line">                    <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;classpath*:&quot;</span> + basePackage.replace(<span class="string">&quot;.&quot;</span>, <span class="string">&quot;/&quot;</span>) + <span class="string">&quot;/**/*.class&quot;</span>;</span><br><span class="line">                    System._out_.println(<span class="string">&quot;path - &quot;</span> + path);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 工厂 - 缓存和读取 Java 类元数据的类，避免重复加载和解析相同的类信息</span></span><br><span class="line">                    <span class="type">CachingMetadataReaderFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CachingMetadataReaderFactory</span>();</span><br><span class="line">                    <span class="comment">// 工具类 - BeanName生成器</span></span><br><span class="line">                    <span class="type">AnnotationBeanNameGenerator</span> <span class="variable">generator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationBeanNameGenerator</span>();</span><br><span class="line">                    <span class="comment">// _Todo 没理解 context -&gt; new PathMatchingResourcePatternResolver()_</span></span><br><span class="line">_                    _Resource[] resources = <span class="keyword">new</span> <span class="title class_">PathMatchingResourcePatternResolver</span>().getResources(path);</span><br><span class="line">                    <span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">                        System._out_.println(resource);</span><br><span class="line">                        <span class="type">MetadataReader</span> <span class="variable">metadataReader</span> <span class="operator">=</span> factory.getMetadataReader(resource);</span><br><span class="line">                        System._out_.println(<span class="string">&quot;类名: &quot;</span> + metadataReader.getClassMetadata().getClassName());</span><br><span class="line">                        <span class="type">AnnotationMetadata</span> <span class="variable">annotationMetadata</span> <span class="operator">=</span> metadataReader.getAnnotationMetadata();</span><br><span class="line">                        System._out_.println(<span class="string">&quot;是否加了@Component: &quot;</span> + annotationMetadata.hasAnnotation(Component.class.getName()));</span><br><span class="line">                        System._out_.println(<span class="string">&quot;是否加了@Component派生注解: &quot;</span> + annotationMetadata.hasMetaAnnotation(Component.class.getName()));</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 有@Component注解及其派生注解（如@Controller）等，注入Spring容器</span></span><br><span class="line">                        <span class="keyword">if</span> (annotationMetadata.hasAnnotation(Component.class.getName())</span><br><span class="line">                                || annotationMetadata.hasMetaAnnotation(Component.class.getName())) &#123;</span><br><span class="line">                            <span class="type">AbstractBeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> BeanDefinitionBuilder</span><br><span class="line">                                    ._genericBeanDefinition_(metadataReader.getClassMetadata().getClassName())</span><br><span class="line">                                    .getBeanDefinition();</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span>(configurableListableBeanFactory <span class="keyword">instanceof</span> DefaultListableBeanFactory beanFactory)&#123;</span><br><span class="line">                                <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> generator.generateBeanName(beanDefinition, beanFactory);</span><br><span class="line">                                beanFactory.registerBeanDefinition(beanName, beanDefinition);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主调 main 方法中只需要将该后置处理器注入即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">main</span><span class="params">(String[] args)</span> throws IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        GenericApplicationContext context = <span class="keyword">new</span> <span class="built_in">GenericApplicationContext</span>();</span><br><span class="line"></span><br><span class="line">        context.<span class="built_in">registerBean</span>(<span class="string">&quot;config&quot;</span>, Config.<span class="keyword">class</span>);</span><br><span class="line">        <span class="comment">// @ComponentScan @Bean @Import @ImportResource</span></span><br><span class="line"><span class="comment">//        context.registerBean(ConfigurationClassPostProcessor.class);</span></span><br><span class="line">        <span class="comment">// @MapperScanner</span></span><br><span class="line"><span class="comment">//        context.registerBean(MapperScannerConfigurer.class, bd -&gt; &#123;</span></span><br><span class="line"><span class="comment">//            bd.getPropertyValues().add(&quot;basePackage&quot;,</span></span><br><span class="line"><span class="comment">//                    &quot;com.example.springbootdemo.study.s05_beanfactory_postprocessor.mapper&quot;);</span></span><br><span class="line"><span class="comment">//        &#125;);</span></span><br><span class="line">        <span class="comment">// 注入自定义的后置处理器</span></span><br><span class="line">        context.<span class="built_in">registerBean</span>(ComponentScanPostProcessor.<span class="keyword">class</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化容器</span></span><br><span class="line">        context.<span class="built_in">refresh</span>();</span><br><span class="line">        System._out_.<span class="built_in">println</span>(<span class="string">&quot;-----------------------------------&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String name : context.<span class="built_in">getBeanDefinitionNames</span>()) &#123;</span><br><span class="line">            System._out_.<span class="built_in">println</span>(<span class="string">&quot;beanName - &quot;</span> + name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        context.<span class="built_in">close</span>();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="5-2-模拟-ConfigurationClassPostProcessor-Bean"><a href="#5-2-模拟-ConfigurationClassPostProcessor-Bean" class="headerlink" title="5.2 模拟 ConfigurationClassPostProcessor - @Bean"></a>5.2 模拟 ConfigurationClassPostProcessor - @Bean</h2><hr><blockquote><p><em>深入理解 ConfigurationClassPostProcessor 后置处理器中关于对带有 @Bean 注解的类的扫描、解析和注入；</em></p></blockquote><p><strong>核心逻辑</strong>：</p><p>首先来理解所谓的 Bean 工厂以及工厂方法，如果某个 Spring 配置类，其中的方法带有 @Bean 注解，代表该方法会用来生产 Bean，那么可以将这个类看作是生产 Bean 的工厂，具体的方法称为工厂方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">xxxConfig</span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Bean1 <span class="title function_">bean1</span><span class="params">()</span>&#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bean1</span>();&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理器会根据类文件目录找寻到 Config.class 二进制文件，解析其中的带有 @Bean 注解的方法，对带有参数的施以正确的注入，并将其封装为 BeanDefinition 注入到 Spring 容器中。</p><blockquote><p><em>通过手动解析指定类（__Config.class__）中的 <strong>@Bean</strong> 注解方法，动态地将这些方法定义的 Bean 注册到 Spring 容器中；</em></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CachingMetadataReaderFactory</span> <span class="variable">metadataReaderFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CachingMetadataReaderFactory</span>();</span><br><span class="line"><span class="comment">// 从指定的 Resource（Config.class 的字节码文件）中读取元数据。</span></span><br><span class="line"><span class="type">MetadataReader</span> <span class="variable">metadataReader</span> <span class="operator">=</span> metadataReaderFactory.getMetadataReader(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;com/example/springbootdemo/study/s05_beanfactory_postprocessor/Config.class&quot;</span>));</span><br><span class="line">Set&lt;MethodMetadata&gt; methods = metadataReader.getAnnotationMetadata().getAnnotatedMethods(Bean.class.getName());</span><br><span class="line"><span class="keyword">for</span> (MethodMetadata method : methods) &#123;</span><br><span class="line">    System._out_.println(method);</span><br><span class="line">    <span class="comment">// 查看当前Bean是否配置了初始化方法</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">initMethod</span> <span class="operator">=</span> method.getAnnotationAttributes(Bean.class.getName()).get(<span class="string">&quot;initMethod&quot;</span>).toString();</span><br><span class="line"></span><br><span class="line">    <span class="type">BeanDefinitionBuilder</span> <span class="variable">beanDefinitionBuilder</span> <span class="operator">=</span> BeanDefinitionBuilder._genericBeanDefinition_();</span><br><span class="line">    <span class="comment">// 指定这个 BeanDefinition 的创建逻辑是通过调用 config Bean 上的方法（即 method.getMethodName()）</span></span><br><span class="line">    beanDefinitionBuilder.setFactoryMethodOnBean(method.getMethodName(), <span class="string">&quot;config&quot;</span>);</span><br><span class="line">    beanDefinitionBuilder.setAutowireMode(AbstractBeanDefinition._AUTOWIRE_CONSTRUCTOR_);</span><br><span class="line">    <span class="comment">// 将初始化方法设置入BeanDefinition中</span></span><br><span class="line">    <span class="keyword">if</span>(!initMethod.isEmpty())&#123;</span><br><span class="line">        beanDefinitionBuilder.setInitMethodName(initMethod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">AbstractBeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> beanDefinitionBuilder.getBeanDefinition();</span><br><span class="line">    <span class="comment">// 约定@Bean的工厂方法名就是该Bean的beanName</span></span><br><span class="line">    context.getDefaultListableBeanFactory().registerBeanDefinition(method.getMethodName(), beanDefinition);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><em>需要对</em><strong>@Bean 的属性</strong><em>做解析；</em><br><em>此处只举例了 initMethod 属性；</em></p></blockquote><p><strong>功能：</strong></p><ul><li>通过手动解析 <code>Config.class</code> 中所有标注了 <code>@Bean</code> 的方法，构建对应的 <code>BeanDefinition</code> 并动态注册到 Spring 容器中。</li></ul><p><strong>核心步骤：</strong></p><ul><li>使用 <code>CachingMetadataReaderFactory</code> 读取类的元数据。</li><li>查找 <code>@Bean</code> 方法并解析其注解属性。</li><li>构建 <code>BeanDefinition</code> 并注册到容器。</li></ul><p><strong>扩展性：</strong></p><ul><li>该代码适合在需要动态加载配置类 Bean 的场景中使用，例如框架扩展、自定义 Bean 注册逻辑等。</li></ul><p><strong>输出结果</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">com.example.springbootdemo.study.s05_beanfactory_postprocessor.Config.<span class="built_in">bean1</span>()</span><br><span class="line">com.example.springbootdemo.study.s05_beanfactory_postprocessor.Config.<span class="built_in">sqlSessionFactoryBean</span>(javax.sql.DataSource)</span><br><span class="line">com.example.springbootdemo.study.s05_beanfactory_postprocessor.Config.<span class="built_in">druidDataSource</span>()</span><br><span class="line"><span class="number">0</span>9:<span class="number">29</span>:<span class="number">44.953</span> [main] INFO com.example.springbootdemo.study.s05_beanfactory_postprocessor.Bean1 -- Bean1 被Spring管理</span><br><span class="line"><span class="number">0</span>9:<span class="number">29</span>:<span class="number">45.052</span> [main] INFO com.alibaba.druid.pool.DruidDataSource -- &#123;dataSource<span class="number">-1</span>&#125; inited</span><br><span class="line">-----------------------------------</span><br><span class="line">beanName - config</span><br><span class="line">beanName - bean1</span><br><span class="line">beanName - sqlSessionFactoryBean</span><br><span class="line">beanName - druidDataSource</span><br><span class="line"><span class="number">0</span>9:<span class="number">29</span>:<span class="number">45.116</span> [main] INFO com.alibaba.druid.pool.DruidDataSource -- &#123;dataSource<span class="number">-1</span>&#125; closing ...</span><br><span class="line"><span class="number">0</span>9:<span class="number">29</span>:<span class="number">45.116</span> [main] INFO com.alibaba.druid.pool.DruidDataSource -- &#123;dataSource<span class="number">-1</span>&#125; closed</span><br></pre></td></tr></table></figure><p>可以看到，@Bean 所标注的方法均生成了对应的 Bean。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">_<span class="comment">/**_</span></span><br><span class="line"><span class="comment">_ * __BeanFactory后置处理器 - 自定义__@Bean__后置处理器_</span></span><br><span class="line"><span class="comment">_ * func - 扫描Config类内的<span class="doctag">@Bean</span>注解下的工厂方法，解析<span class="doctag">@Bean</span>属性，构建BeanDefinition完成注入_</span></span><br><span class="line"><span class="comment">_ * _</span></span><br><span class="line"><span class="comment">_ * _**<span class="doctag">@author</span> **_limoukun_</span></span><br><span class="line"><span class="comment">_ * _**<span class="doctag">@since</span> **_2025/1/3 _</span></span><br><span class="line"><span class="comment">_ **/</span>_</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanFactoryPostProcessor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory configurableListableBeanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">CachingMetadataReaderFactory</span> <span class="variable">metadataReaderFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CachingMetadataReaderFactory</span>();</span><br><span class="line">            <span class="comment">// 从指定的 Resource（Config.class 的字节码文件）中读取元数据。</span></span><br><span class="line">            <span class="type">MetadataReader</span> <span class="variable">metadataReader</span> <span class="operator">=</span> metadataReaderFactory.getMetadataReader(</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;com/example/springbootdemo/study/s05_beanfactory_postprocessor/Config.class&quot;</span>));</span><br><span class="line">            Set&lt;MethodMetadata&gt; methods = metadataReader.getAnnotationMetadata().getAnnotatedMethods(Bean.class.getName());</span><br><span class="line">            <span class="keyword">for</span> (MethodMetadata method : methods) &#123;</span><br><span class="line">                System._out_.println(method);</span><br><span class="line">                <span class="comment">// 查看当前Bean是否配置了初始化方法</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">initMethod</span> <span class="operator">=</span> method.getAnnotationAttributes(Bean.class.getName()).get(<span class="string">&quot;initMethod&quot;</span>).toString();</span><br><span class="line"></span><br><span class="line">                <span class="type">BeanDefinitionBuilder</span> <span class="variable">beanDefinitionBuilder</span> <span class="operator">=</span> BeanDefinitionBuilder._genericBeanDefinition_();</span><br><span class="line">                <span class="comment">// 指定这个 BeanDefinition 的创建逻辑是通过调用 config Bean 上的方法（即 method.getMethodName()）</span></span><br><span class="line">                beanDefinitionBuilder.setFactoryMethodOnBean(method.getMethodName(), <span class="string">&quot;config&quot;</span>);</span><br><span class="line">                beanDefinitionBuilder.setAutowireMode(AbstractBeanDefinition._AUTOWIRE_CONSTRUCTOR_);</span><br><span class="line">                <span class="comment">// 将初始化方法设置入BeanDefinition中</span></span><br><span class="line">                <span class="keyword">if</span>(!initMethod.isEmpty())&#123;</span><br><span class="line">                    beanDefinitionBuilder.setInitMethodName(initMethod);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">AbstractBeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> beanDefinitionBuilder.getBeanDefinition();</span><br><span class="line">                <span class="comment">// 约定@Bean的工厂方法名就是该Bean的beanName</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (configurableListableBeanFactory <span class="keyword">instanceof</span> DefaultListableBeanFactory beanFactory)&#123;</span><br><span class="line">                    beanFactory.registerBeanDefinition(method.getMethodName(), beanDefinition);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-3-模拟-MapperScannerConfigurer-Mapper"><a href="#5-3-模拟-MapperScannerConfigurer-Mapper" class="headerlink" title="5.3 模拟 MapperScannerConfigurer - @Mapper"></a>5.3 模拟 MapperScannerConfigurer - @Mapper</h2><hr><blockquote><p><em>深入理解</em><strong>MapperScannerConfigurer</strong><em>后置处理器中关于对带有 @Mapper 注解的类的扫描、解析和注入；</em><br><em>该过程即 Spring 与 MyBatis 的整合过程；</em></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">_<span class="comment">/**_</span></span><br><span class="line"><span class="comment">_ * BeanFactory后置处理器 - 自定义<span class="doctag">@Mapper</span>后置处理器_</span></span><br><span class="line"><span class="comment">_ * func - _</span></span><br><span class="line"><span class="comment">_ * _</span></span><br><span class="line"><span class="comment">_ * _**<span class="doctag">@author</span> **_limoukun_</span></span><br><span class="line"><span class="comment">_ * _**<span class="doctag">@since</span> **_2025/1/3 _</span></span><br><span class="line"><span class="comment">_ **/</span>_</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapperPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanDefinitionRegistryPostProcessor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry beanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1. 获取指定二进制类文件资源</span></span><br><span class="line">            <span class="type">PathMatchingResourcePatternResolver</span> <span class="variable">resolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PathMatchingResourcePatternResolver</span>();</span><br><span class="line">            Resource[] resources = resolver.getResources(<span class="string">&quot;classpath:com/example/springbootdemo/study/s05_beanfactory_postprocessor/mapper/**/*.class&quot;</span>);</span><br><span class="line">            <span class="type">CachingMetadataReaderFactory</span> <span class="variable">metadataReaderFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CachingMetadataReaderFactory</span>();</span><br><span class="line">            <span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">                System._out_.println(<span class="string">&quot;resource: &quot;</span> + resource);</span><br><span class="line">                <span class="comment">// 2. 逐资源读取元数据</span></span><br><span class="line">                <span class="type">MetadataReader</span> <span class="variable">metadataReader</span> <span class="operator">=</span> metadataReaderFactory.getMetadataReader(resource);</span><br><span class="line">                <span class="comment">// 2.1 判断是否是接口（Mapper接口）</span></span><br><span class="line">                <span class="type">ClassMetadata</span> <span class="variable">classMetadata</span> <span class="operator">=</span> metadataReader.getClassMetadata();</span><br><span class="line">                <span class="keyword">if</span>(classMetadata.isInterface()) &#123;</span><br><span class="line">                    <span class="comment">// 2.2 创建BeanDefinition：构造参数、自动注入方式</span></span><br><span class="line">                    <span class="type">AbstractBeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> BeanDefinitionBuilder._genericBeanDefinition_(MapperFactoryBean.class)</span><br><span class="line">                            .setAutowireMode(AbstractBeanDefinition._AUTOWIRE_BY_TYPE_)</span><br><span class="line">                            .addConstructorArgValue(Mapper1.class.getName())</span><br><span class="line">                            .getBeanDefinition();</span><br><span class="line">                    System._out_.println(<span class="string">&quot;classMetadata.getClassName(): &quot;</span> + classMetadata.getClassName());</span><br><span class="line">                    <span class="comment">// 2.3 构建beanName</span></span><br><span class="line">                    <span class="comment">// 2.4 完成bean注入</span></span><br><span class="line">                    beanFactory.registerBeanDefinition(classMetadata.getClassName(), beanDefinition);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Q：关于-BeanDefinition-注入时-beanName-的考虑？"><a href="#Q：关于-BeanDefinition-注入时-beanName-的考虑？" class="headerlink" title="Q：关于 BeanDefinition 注入时 beanName 的考虑？"></a>Q：关于 BeanDefinition 注入时 beanName 的考虑？</h3><hr><p><strong>思考</strong>：此处关于 Mapper 的 BeanName 采用了元数据中 <code>classMetadata.getClassName()</code>，意味着将使用该 Mapper 的全限定包名作为注入时的 beanName，因此注入 Spring 的结果为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">beanName - com.example.springbootdemo.study.s05_beanfactory_postprocessor.mapper.Mapper1</span><br><span class="line">beanName - com.example.springbootdemo.study.s05_beanfactory_postprocessor.mapper.Mapper2</span><br></pre></td></tr></table></figure><p>我们用 mapper1 或 mapper2 进行查询就会发现 Spring 容器中不存在对应名字的 Bean（但我们的目的便是创建 mapper1、mapper2 两个 Bean）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main中</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">mapper1</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;mapper1&quot;</span>);</span><br><span class="line">System._out_.println(<span class="string">&quot;尝试获取BeanName为mapper1的Bean - &quot;</span> + mapper1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 控制台输出</span></span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> org.springframework.beans.factory.NoSuchBeanDefinitionException: **No bean named <span class="string">&#x27;mapper1&#x27;</span> available**</span><br><span class="line">        at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBeanDefinition(DefaultListableBeanFactory.java:<span class="number">893</span>)</span><br><span class="line">        at org.springframework.beans.factory.support.AbstractBeanFactory.getMergedLocalBeanDefinition(AbstractBeanFactory.java:<span class="number">1316</span>)</span><br><span class="line">        at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:<span class="number">299</span>)</span><br><span class="line">        at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:<span class="number">199</span>)</span><br><span class="line">        at org.springframework.context.support.AbstractApplicationContext.getBean(AbstractApplicationContext.java:<span class="number">1158</span>)</span><br><span class="line">        at com.example.springbootdemo.study.s05_beanfactory_postprocessor.Application_04.main(Application_04.java:<span class="number">43</span>)</span><br></pre></td></tr></table></figure><hr><p>聚焦于 for-each 循环中，<strong>关于 BeanDefinition 注入时 beanName 的处理</strong>。</p><p>此处我们构建了 AnnotationBeanNameGenerator 用来根据已创建的 beanDefinition 在 beanFactory 中找到对应的 beanName：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AnnotationBeanNameGenerator</span> <span class="variable">generator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationBeanNameGenerator</span>();</span><br><span class="line"><span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">    System._out_.println(<span class="string">&quot;resource: &quot;</span> + resource);</span><br><span class="line">    <span class="comment">// 2. 逐资源读取元数据</span></span><br><span class="line">    <span class="type">MetadataReader</span> <span class="variable">metadataReader</span> <span class="operator">=</span> metadataReaderFactory.getMetadataReader(resource);</span><br><span class="line">    <span class="comment">// 2.1 判断是否是接口（Mapper接口）</span></span><br><span class="line">    <span class="type">ClassMetadata</span> <span class="variable">classMetadata</span> <span class="operator">=</span> metadataReader.getClassMetadata();</span><br><span class="line">    <span class="keyword">if</span>(classMetadata.isInterface()) &#123;</span><br><span class="line">        <span class="comment">// 2.2 创建BeanDefinition：构造参数、自动注入方式</span></span><br><span class="line">        <span class="type">AbstractBeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> BeanDefinitionBuilder._genericBeanDefinition_(MapperFactoryBean.class)</span><br><span class="line">                .setAutowireMode(AbstractBeanDefinition._AUTOWIRE_BY_TYPE_)</span><br><span class="line">                .addConstructorArgValue(Mapper1.class.getName())</span><br><span class="line">                .getBeanDefinition();</span><br><span class="line">        System._out_.println(<span class="string">&quot;classMetadata.getClassName(): &quot;</span> + classMetadata.getClassName());</span><br><span class="line">        <span class="comment">// 2.3 构建beanName</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> generator.generateBeanName(beanDefinition, beanFactory);</span><br><span class="line">        System._out_.println(<span class="string">&quot;构建的beanName: &quot;</span> + beanName);</span><br><span class="line">        <span class="comment">// 2.4 完成bean注入</span></span><br><span class="line">        beanFactory.registerBeanDefinition(beanName, beanDefinition);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">resource: file [D:\JAVA\workSpace\springBootDemo\target\classes\com\example\springbootdemo\study\s05_beanfactory_postprocessor\mapper\Mapper1.class]</span><br><span class="line">classMetadata.getClassName(): com.example.springbootdemo.study.s05_beanfactory_postprocessor.mapper.Mapper1</span><br><span class="line">构建的beanName: **mapperFactoryBean**</span><br><span class="line">resource: file [D:\JAVA\workSpace\springBootDemo\target\classes\com\example\springbootdemo\study\s05_beanfactory_postprocessor\mapper\Mapper2.class]</span><br><span class="line">classMetadata.getClassName(): com.example.springbootdemo.study.s05_beanfactory_postprocessor.mapper.Mapper2</span><br><span class="line">构建的beanName: **mapperFactoryBean**</span><br><span class="line"></span><br><span class="line">beanName - mapperFactoryBean</span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> org.springframework.beans.factory.NoSuchBeanDefinitionException: No bean named <span class="string">&#x27;mapper1&#x27;</span> available</span><br><span class="line">        at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBeanDefinition(DefaultListableBeanFactory.java:<span class="number">893</span>)</span><br><span class="line">        at org.springframework.beans.factory.support.AbstractBeanFactory.getMergedLocalBeanDefinition(AbstractBeanFactory.java:<span class="number">1316</span>)</span><br><span class="line">        at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:<span class="number">299</span>)</span><br><span class="line">        at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:<span class="number">199</span>)</span><br><span class="line">        at org.springframework.context.support.AbstractApplicationContext.getBean(AbstractApplicationContext.java:<span class="number">1158</span>)</span><br><span class="line">        at com.example.springbootdemo.study.s05_beanfactory_postprocessor.Application_04.main(Application_04.java:<span class="number">43</span>)</span><br></pre></td></tr></table></figure><p><strong>分析</strong>：由于我们在构建 BeanDefinition 时，传入的类型是 <code>MapperFactoryBean.class</code>，导致 mapper1 和 mapper2 先后两次生成的 beanName 都是 <code>mapperFactoryBean</code>，而并非是 mapper1&#x2F;mapper2，又由于 Spring 对于重复的 Bean 只会择最后一次注入的为准，因此 Spring 容器中只有一个名为 <code>mapperFactoryBean</code>(注意是小写 m 打头)的 Bean。</p><hr><p>由于当前生成的 beanName 受限于创建的 BeanDefinition（已绑定为 MapperFactoryBean.class），因此参照 Spring 内部的逻辑，我们再基于当前 Mapper 接口的类信息构建一次 BeanDefinition，并基于此生成出 beanName，就能够解决问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AnnotationBeanNameGenerator</span> <span class="variable">generator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationBeanNameGenerator</span>();</span><br><span class="line"><span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">    System._out_.println(<span class="string">&quot;resource: &quot;</span> + resource);</span><br><span class="line">    <span class="comment">// 2. 逐资源读取元数据</span></span><br><span class="line">    <span class="type">MetadataReader</span> <span class="variable">metadataReader</span> <span class="operator">=</span> metadataReaderFactory.getMetadataReader(resource);</span><br><span class="line">    <span class="comment">// 2.1 判断是否是接口（Mapper接口）</span></span><br><span class="line">    <span class="type">ClassMetadata</span> <span class="variable">classMetadata</span> <span class="operator">=</span> metadataReader.getClassMetadata();</span><br><span class="line">    <span class="keyword">if</span>(classMetadata.isInterface()) &#123;</span><br><span class="line">        <span class="comment">// 2.2 创建BeanDefinition：构造参数、自动注入方式</span></span><br><span class="line">        <span class="type">AbstractBeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> BeanDefinitionBuilder._genericBeanDefinition_(MapperFactoryBean.class)</span><br><span class="line">                .setAutowireMode(AbstractBeanDefinition._AUTOWIRE_BY_TYPE_)</span><br><span class="line">                .addConstructorArgValue(Mapper1.class.getName())</span><br><span class="line">                .getBeanDefinition();</span><br><span class="line">        System._out_.println(<span class="string">&quot;classMetadata.getClassName(): &quot;</span> + classMetadata.getClassName());</span><br><span class="line">        <span class="comment">// 2.3 构建beanName</span></span><br><span class="line">        <span class="comment">// String beanName = generator.generateBeanName(beanDefinition, beanFactory);</span></span><br><span class="line">        <span class="type">AbstractBeanDefinition</span> <span class="variable">beanDefinition1</span> <span class="operator">=</span> BeanDefinitionBuilder</span><br><span class="line">                ._genericBeanDefinition_(classMetadata.getClassName())</span><br><span class="line">                .getBeanDefinition();</span><br><span class="line">        <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> generator.generateBeanName(beanDefinition1, beanFactory);</span><br><span class="line">        System._out_.println(<span class="string">&quot;构建的beanName: &quot;</span> + beanName);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.4 完成bean注入</span></span><br><span class="line">        beanFactory.registerBeanDefinition(beanName, beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">resource: file [D:\JAVA\workSpace\springBootDemo\target\classes\com\example\springbootdemo\study\s05_beanfactory_postprocessor\mapper\Mapper1.class]</span><br><span class="line">classMetadata.getClassName(): com.example.springbootdemo.study.s05_beanfactory_postprocessor.mapper.Mapper1</span><br><span class="line">构建的beanName: mapper1</span><br><span class="line">resource: file [D:\JAVA\workSpace\springBootDemo\target\classes\com\example\springbootdemo\study\s05_beanfactory_postprocessor\mapper\Mapper2.class]</span><br><span class="line">classMetadata.getClassName(): com.example.springbootdemo.study.s05_beanfactory_postprocessor.mapper.Mapper2</span><br><span class="line">构建的beanName: mapper2</span><br><span class="line"></span><br><span class="line">beanName - mapper1</span><br><span class="line">beanName - mapper2</span><br><span class="line">尝试获取BeanName为mapper1的Bean - org.apache.ibatis.binding.MapperProxy@18a136ac</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">_<span class="comment">/**_</span></span><br><span class="line"><span class="comment">_ * BeanFactory后置处理器 - 自定义<span class="doctag">@Mapper</span>后置处理器_</span></span><br><span class="line"><span class="comment">_ * func - 扫描mapper包下的所有带有<span class="doctag">@Mapper</span>的MyBaits定义接口，解析并完成对应Bean的注入_</span></span><br><span class="line"><span class="comment">_ *_</span></span><br><span class="line"><span class="comment">_ * _**<span class="doctag">@author</span> **_limoukun_</span></span><br><span class="line"><span class="comment">_ * _**<span class="doctag">@since</span> **_2025/1/3_</span></span><br><span class="line"><span class="comment">_ **/</span>_</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapperPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanDefinitionRegistryPostProcessor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry beanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1. 获取指定二进制类文件资源</span></span><br><span class="line">            <span class="type">PathMatchingResourcePatternResolver</span> <span class="variable">resolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PathMatchingResourcePatternResolver</span>();</span><br><span class="line">            Resource[] resources = resolver.getResources(<span class="string">&quot;classpath:com/example/springbootdemo/study/s05_beanfactory_postprocessor/mapper/**/*.class&quot;</span>);</span><br><span class="line">            <span class="type">CachingMetadataReaderFactory</span> <span class="variable">metadataReaderFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CachingMetadataReaderFactory</span>();</span><br><span class="line">            <span class="type">AnnotationBeanNameGenerator</span> <span class="variable">generator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationBeanNameGenerator</span>();</span><br><span class="line">            <span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">                System._out_.println(<span class="string">&quot;resource: &quot;</span> + resource);</span><br><span class="line">                <span class="comment">// 2. 逐资源读取元数据</span></span><br><span class="line">                <span class="type">MetadataReader</span> <span class="variable">metadataReader</span> <span class="operator">=</span> metadataReaderFactory.getMetadataReader(resource);</span><br><span class="line">                <span class="comment">// 2.1 判断是否是接口（Mapper接口）</span></span><br><span class="line">                <span class="type">ClassMetadata</span> <span class="variable">classMetadata</span> <span class="operator">=</span> metadataReader.getClassMetadata();</span><br><span class="line">                <span class="keyword">if</span>(classMetadata.isInterface()) &#123;</span><br><span class="line">                    <span class="comment">// 2.2 创建BeanDefinition：构造参数、自动注入方式</span></span><br><span class="line">                    <span class="type">AbstractBeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> BeanDefinitionBuilder._genericBeanDefinition_(MapperFactoryBean.class)</span><br><span class="line">                            .setAutowireMode(AbstractBeanDefinition._AUTOWIRE_BY_TYPE_)</span><br><span class="line">                            .addConstructorArgValue(Mapper1.class.getName())</span><br><span class="line">                            .getBeanDefinition();</span><br><span class="line">                    System._out_.println(<span class="string">&quot;classMetadata.getClassName(): &quot;</span> + classMetadata.getClassName());</span><br><span class="line">                    <span class="comment">// 2.3 构建beanName</span></span><br><span class="line"><span class="comment">//                    String beanName = generator.generateBeanName(beanDefinition, beanFactory);</span></span><br><span class="line">                    <span class="type">AbstractBeanDefinition</span> <span class="variable">beanDefinition1</span> <span class="operator">=</span> BeanDefinitionBuilder</span><br><span class="line">                            ._genericBeanDefinition_(classMetadata.getClassName())</span><br><span class="line">                            .getBeanDefinition();</span><br><span class="line">                    <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> generator.generateBeanName(beanDefinition1, beanFactory);</span><br><span class="line">                    System._out_.println(<span class="string">&quot;构建的beanName: &quot;</span> + beanName);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 2.4 完成bean注入</span></span><br><span class="line">                    beanFactory.registerBeanDefinition(beanName, beanDefinition);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="六、Aware-与-InitializingBean-接口"><a href="#六、Aware-与-InitializingBean-接口" class="headerlink" title="六、Aware 与 InitializingBean 接口"></a>六、Aware 与 InitializingBean 接口</h1><hr><p><img src="/static/Oyd4bB0Pxo11XhxCTvHc5mpInWf.png"></p><p><strong>网友理解</strong>：</p><ul><li>个别情况不能用注解注入，只能用实现 aware 接口的类进行手动注入，应用开发了解即可；</li><li>当你需要使用容器的时候，那个发布事件的功能，需要用到 context 容器，你要使用 Aware 这样的机制获取 context，当然，你使用 autowired 也可以；</li></ul><p><img src="/static/RpfIbjuLXognyWxyZ15c4Wcin0d.png"></p><h2 id="6-1-BeanNameAware、ApplicationContextAware"><a href="#6-1-BeanNameAware、ApplicationContextAware" class="headerlink" title="6.1 BeanNameAware、ApplicationContextAware"></a>6.1 BeanNameAware、ApplicationContextAware</h2><hr><p>在 Spring 中，实现了 <code>BeanNameAware</code> 接口的类可以感知到它在 Spring 容器中所对应的 <strong>bean 的名字</strong>。这个接口的主要作用是：</p><ol><li><strong>注入 bean 的名字</strong>：让 bean 知道它在容器中的名字；</li><li><strong>实现自定义逻辑</strong>：在获取到 beanName 后，实现一些与其名字相关的自定义逻辑；</li></ol><blockquote><p><em>BeanNameAware</em>_ 的核心目标是 _<strong>让 bean 知道自己的名字</strong><em>，而非让外界知道其名字或为其设置名字；</em></p></blockquote><p><strong>&gt;&gt; BeanNameAware 接口：是 Spring 的<strong><strong>内置接口</strong></strong>（非拓展接口）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanNameAware</span> <span class="keyword">extends</span> <span class="title class_">Aware</span> &#123;</span><br><span class="line"></span><br><span class="line">    _<span class="comment">/**_</span></span><br><span class="line"><span class="comment">_     * Set the name of the bean in the bean factory that created this bean._</span></span><br><span class="line"><span class="comment">_     * &lt;p&gt;Invoked after population of normal bean properties but before an_</span></span><br><span class="line"><span class="comment">_     * init callback such as &#123;_**<span class="doctag">@link</span> **_InitializingBean#afterPropertiesSet()&#125;_</span></span><br><span class="line"><span class="comment">_     * or a custom init-method._</span></span><br><span class="line"><span class="comment">_     * _**<span class="doctag">@param</span> **_name the name of the bean in the factory._</span></span><br><span class="line"><span class="comment">_     * Note that this name is the actual bean name used in the factory, which may_</span></span><br><span class="line"><span class="comment">_     * differ from the originally specified name: in particular for inner bean_</span></span><br><span class="line"><span class="comment">_     * names, the actual bean name might have been made unique through appending_</span></span><br><span class="line"><span class="comment">_     * &quot;#...&quot; suffixes. Use the &#123;_**<span class="doctag">@link</span> **_BeanFactoryUtils#originalBeanName(String)&#125;_</span></span><br><span class="line"><span class="comment">_     * method to extract the original bean name (without suffix), if desired._</span></span><br><span class="line"><span class="comment">_     */</span>_</span><br><span class="line">_    _void <span class="title function_">setBeanName</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当一个 Bean 实现该接口后，Spring 容器会在完成 Bean 的实例化和属性填充后、初始化回调方法（如 <code>@PostConstruct</code> 或 <code>InitializingBean#afterPropertiesSet</code>）之前调用 <code>setBeanName(String name)</code> 方法，把该 bean 在容器中的名字注入进去。</p><p><strong>&gt;&gt; 使用场景：</strong></p><ul><li>日志记录：在调试或日志中记录 bean 的名字，方便排查问题。</li><li>动态行为：根据 bean 名字调整行为，例如为不同名字的 bean 加载不同的配置。</li><li>框架开发：在开发自定义框架时，通过感知 bean 名字实现对容器中 bean 的管理</li></ul><p>实现该接口的类能够访问到 Spring 容器（即 <code>ApplicationContext</code>）本身，从而让 bean 知道它是在哪个应用上下文中运行的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ApplicationContextAware</span> <span class="keyword">extends</span> <span class="title class_">Aware</span> &#123;</span><br><span class="line"></span><br><span class="line">    _<span class="comment">/**_</span></span><br><span class="line"><span class="comment">_     * Set the ApplicationContext that this object runs in._</span></span><br><span class="line"><span class="comment">_     * Normally this call will be used to initialize the object._</span></span><br><span class="line"><span class="comment">_     * &lt;p&gt;Invoked after population of normal bean properties but before an init callback such_</span></span><br><span class="line"><span class="comment">_     * as &#123;_**<span class="doctag">@link</span> **_org.springframework.beans.factory.InitializingBean#afterPropertiesSet()&#125;_</span></span><br><span class="line"><span class="comment">_     * or a custom init-method. Invoked after &#123;_**<span class="doctag">@link</span> **_ResourceLoaderAware#setResourceLoader&#125;,_</span></span><br><span class="line"><span class="comment">_     * &#123;_**<span class="doctag">@link</span> **_ApplicationEventPublisherAware#setApplicationEventPublisher&#125; and_</span></span><br><span class="line"><span class="comment">_     * &#123;_**<span class="doctag">@link</span> **_MessageSourceAware&#125;, if applicable._</span></span><br><span class="line"><span class="comment">_     * _**<span class="doctag">@param</span> **_applicationContext the ApplicationContext object to be used by this object_</span></span><br><span class="line"><span class="comment">_     * _**<span class="doctag">@throws</span> **_ApplicationContextException in case of context initialization errors_</span></span><br><span class="line"><span class="comment">_     * _**<span class="doctag">@throws</span> **_BeansException if thrown by application context methods_</span></span><br><span class="line"><span class="comment">_     * _**<span class="doctag">@see</span> **_org.springframework.beans.factory.BeanInitializationException_</span></span><br><span class="line"><span class="comment">_     */</span>_</span><br><span class="line">_    _void <span class="title function_">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现 <code>ApplicationContextAware</code> 接口的类可以在 Spring 容器创建并初始化 bean 后，获取到 <code>ApplicationContext</code> 实例，从而访问到 Spring 容器中的其他组件、配置或者 bean。</p><blockquote><p><strong>用途</strong><em>：获取协作 Bean、资源访问、事件发布（需要传入 Context）、消息源访问；</em></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;myBean&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBean</span> <span class="keyword">implements</span> <span class="title class_">BeanNameAware</span>, ApplicationContextAware, InitializingBean &#123;</span><br><span class="line">    _<span class="comment">/**_</span></span><br><span class="line"><span class="comment">_     * 实现BeanNameAware - 注入Bean的名字_</span></span><br><span class="line"><span class="comment">_     *_</span></span><br><span class="line"><span class="comment">_     * _**<span class="doctag">@param</span> **_name_</span></span><br><span class="line"><span class="comment">_     **/</span>_</span><br><span class="line">_    _<span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBeanName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        _log_.info(<span class="string">&quot;bean - &#123;&#125;, beanName - &#123;&#125;&quot;</span>, <span class="built_in">this</span>, name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _<span class="comment">/**_</span></span><br><span class="line"><span class="comment">_     * 实现ApplicationContextAware - 注入Spring容器_</span></span><br><span class="line"><span class="comment">_     *_</span></span><br><span class="line"><span class="comment">_     * _**<span class="doctag">@param</span> **_applicationContext Spring容器_</span></span><br><span class="line"><span class="comment">_     **/</span>_</span><br><span class="line">_    _<span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        _log_.info(<span class="string">&quot;bean - &#123;&#125;, applicationContext - &#123;&#125;&quot;</span>, <span class="built_in">this</span>, applicationContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _<span class="comment">/**_</span></span><br><span class="line"><span class="comment">_     * 实现InitializingBean - 初始化前添加自定义逻辑 _</span></span><br><span class="line"><span class="comment">_     **/</span>_</span><br><span class="line">_    _<span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        _log_.info(<span class="string">&quot;bean - &#123;&#125; 初始化&quot;</span>, <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line"></span><br><span class="line">    context.registerBean(<span class="string">&quot;myBean&quot;</span>, MyBean.class);</span><br><span class="line"></span><br><span class="line">    context.refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">17</span>:<span class="number">15</span>:<span class="number">12.277</span> [main] INFO myBean -- bean - com.example.springbootdemo.study.s06_aware_initializingBean.MyBean@3578436e, beanName - myBean</span><br><span class="line"><span class="number">17</span>:<span class="number">15</span>:<span class="number">12.283</span> [main] INFO myBean -- bean - com.example.springbootdemo.study.s06_aware_initializingBean.MyBean@3578436e, applicationContext - org.springframework.context.support.GenericApplicationContext@64616ca2, started on Tue Jan <span class="number">07</span> <span class="number">17</span>:<span class="number">15</span>:<span class="number">12</span> GMT+08:<span class="number">00</span> <span class="number">2025</span></span><br><span class="line"><span class="number">17</span>:<span class="number">15</span>:<span class="number">12.300</span> [main] INFO myBean -- bean - com.example.springbootdemo.study.s06_aware_initializingBean.MyBean@3578436e 初始化</span><br></pre></td></tr></table></figure><h3 id="Q：-Autowired-能够平替-ApplicationContextAware-接口功能，为什么还使用-Aware-接口呢？"><a href="#Q：-Autowired-能够平替-ApplicationContextAware-接口功能，为什么还使用-Aware-接口呢？" class="headerlink" title="Q：@Autowired 能够平替 ApplicationContextAware 接口功能，为什么还使用 Aware 接口呢？"></a>Q：@Autowired 能够平替 ApplicationContextAware 接口功能，为什么还使用 Aware 接口呢？</h3><hr><p>对 <code>@Autowired</code> 的解析需要用到 Bean 的后置处理器，属于是 Spring 的扩展功能；</p><p>而 Aware 接口属于内置功能，不加任何扩展的情况下 Spring 就能够识别出；</p><p>先看如下例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//        context.registerBean(&quot;myBean&quot;, MyBean.class);</span></span><br><span class="line">    context.registerBean(<span class="string">&quot;config1&quot;</span>,Config1.class);</span><br><span class="line">    context.registerBean(AutowiredAnnotationBeanPostProcessor.class);</span><br><span class="line">    context.registerBean(CommonAnnotationBeanPostProcessor.class);</span><br><span class="line">    context.registerBean(ConfigurationClassPostProcessor.class);</span><br><span class="line"></span><br><span class="line">    context.refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Config1.java</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;Config1&quot;)</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Config1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span>&#123;</span><br><span class="line">        _log_.info(<span class="string">&quot;注入 ApplicationContext&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">        _log_.info(<span class="string">&quot;初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">17</span>:<span class="number">38</span>:<span class="number">29.848</span> [main] INFO Config1 -- 注入 ApplicationContext</span><br><span class="line"><span class="number">17</span>:<span class="number">38</span>:<span class="number">29.850</span> [main] INFO Config1 -- 初始化</span><br></pre></td></tr></table></figure><p><code>@Autowired</code> 注解和 <code>@PostConstruct</code> 注解能够正常被解析，说明对应的后置处理器都能够正常注入 Spring 容器；</p><hr><p>将 Config1 修改如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;Config1&quot;)</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Config1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span>&#123;</span><br><span class="line">        _log_.info(<span class="string">&quot;注入 ApplicationContext&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">        _log_.info(<span class="string">&quot;初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> BeanFactoryPostProcessor <span class="title function_">processor</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beanFactory -&gt; &#123;</span><br><span class="line">            _log_.info(<span class="string">&quot;执行processor&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">context.registerBean(<span class="string">&quot;config1&quot;</span>,Config1.class);</span><br><span class="line"><span class="comment">//        context.registerBean(&quot;config2&quot;,Config2.class);</span></span><br><span class="line">context.registerBean(AutowiredAnnotationBeanPostProcessor.class);</span><br><span class="line">context.registerBean(CommonAnnotationBeanPostProcessor.class);</span><br><span class="line">context.registerBean(ConfigurationClassPostProcessor.class);</span><br><span class="line"></span><br><span class="line">context.refresh();</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span>:<span class="number">42</span>:<span class="number">14.208</span> [main] INFO org.springframework.context.annotation.ConfigurationClassEnhancer -- <span class="meta">@Bean</span> method Config1.processor is non-<span class="keyword">static</span> and returns an object assignable to Spring<span class="string">&#x27;s BeanFactoryPostProcessor interface. This will result in a failure to process annotations such as @Autowired, @Resource and @PostConstruct within the method&#x27;</span>s declaring <span class="meta">@Configuration</span> class. Add the <span class="string">&#x27;static&#x27;</span> modifier to <span class="built_in">this</span> method to avoid these container lifecycle issues; see <span class="meta">@Bean</span> javadoc <span class="keyword">for</span> complete details.</span><br><span class="line"><span class="number">10</span>:<span class="number">42</span>:<span class="number">14.210</span> [main] INFO Config1 -- 执行processor</span><br></pre></td></tr></table></figure><p><strong>分析</strong>：<code>@Autowired</code> 注解和 <code>@PostConstruct</code> 注解不能被正确解析，BeanFactoryProcessor 被注入 Spring；</p><p>正常的 Spring 生命周期如下（配置类中不含 BeanFactoryPostProcessor 注入）：</p><p><img src="/static/AwzSbOtJVoiKmqxeXwLcRvuTnld.png"></p><p>顺序依次是：BeanFactoryPostProcessor（Bean 工厂后置处理器）、BeanPostProcessor（Bean 生命周期后置处理器）、完成 Bean 的实例化和初始化；</p><p>而当前情形是<strong>配置类中包含了****BeanFactoryPostProcessor</strong>，使得要创建其中的 <code>BeanFactoryPostProcessor</code> 必须<strong>提前创建和初始化</strong>出 Java 配置类，但这时候的配置类还未准备好其它的扩展 <code>BeanPostProcessor</code>，就要开始执行 <code>BeanFactoryPostProcessor</code>，导致没有对应的 Bean 后置处理器解析 <code>@Autowired</code> 注解。</p><blockquote><p><em>初始化过程中，Spring 内置的方法如 Aware 接口以及 InitializingBean 接口的回调方法会被执行；</em></p></blockquote><p><img src="/static/VRhqb6ok0oDXQaxWOVQc7fjln5u.png"></p><hr><ol><li>用内置依赖注入和初始化取代扩展依赖注入和初始化；</li><li>用静态工厂方法代替实例工厂方法，避免工厂对象提前被创建；</li></ol><p>此处我们探讨方案一。</p><p>在 Config2 配置类中，采用实现内置依赖注入和初始化接口的方式实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;Config1&quot;)</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Config2</span> <span class="keyword">implements</span> <span class="title class_">ApplicationContextAware</span>, InitializingBean &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        _log_.info(<span class="string">&quot;初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        _log_.info(<span class="string">&quot;注入 ApplicationContext&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> BeanFactoryPostProcessor <span class="title function_">processor</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beanFactory -&gt; &#123;</span><br><span class="line">            _log_.info(<span class="string">&quot;执行processor&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11</span>:<span class="number">19</span>:<span class="number">33.141</span> [main] INFO Config1 -- 注入 ApplicationContext</span><br><span class="line"><span class="number">11</span>:<span class="number">19</span>:<span class="number">33.143</span> [main] INFO Config1 -- 初始化</span><br><span class="line"><span class="number">11</span>:<span class="number">19</span>:<span class="number">33.145</span> [main] INFO org.springframework.context.annotation.ConfigurationClassEnhancer -- <span class="meta">@Bean</span> method Config2.processor is non-<span class="keyword">static</span> and returns an object assignable to Spring<span class="string">&#x27;s BeanFactoryPostProcessor interface. This will result in a failure to process annotations such as @Autowired, @Resource and @PostConstruct within the method&#x27;</span>s declaring <span class="meta">@Configuration</span> class. Add the <span class="string">&#x27;static&#x27;</span> modifier to <span class="built_in">this</span> method to avoid these container lifecycle issues; see <span class="meta">@Bean</span> javadoc <span class="keyword">for</span> complete details.</span><br><span class="line"><span class="number">11</span>:<span class="number">19</span>:<span class="number">33.146</span> [main] INFO Config1 -- 执行processor</span><br></pre></td></tr></table></figure><ol><li>Aware 接口、提供【内置】的注入手段；</li><li>InitializingBean 接口提供了一种【内置】的初始化手段；</li><li>内置的注入和初始化不受扩展功能的影响，总会被执行，因此在 Spring 框架内部经常会被使用；</li></ol><h3 id="Q：关于为什么-Bean-会被解析？"><a href="#Q：关于为什么-Bean-会被解析？" class="headerlink" title="Q：关于为什么 @Bean 会被解析？"></a>Q：关于为什么 @Bean 会被解析？</h3><hr><p>在 Spring 容器的启动过程中，<code>ConfigurationClassPostProcessor</code> 作为一个特殊的 <code>BeanFactoryPostProcessor</code>，会在 <code>BeanFactoryPostProcessor</code> 被调用的阶段被调用。</p><p>自定义的 <code>BeanFactoryPostProcessor</code> 会在 <code>ConfigurationClassPostProcessor</code> 之后执行，因为 Spring 首先需要 <code>ConfigurationClassPostProcessor</code> 来解析配置类，生成正确的 Bean 定义。</p><p>内置和自定义 <code>BeanFactoryPostProcessor</code> 的执行顺序：</p><ul><li><p>Spring 会将 <code>BeanFactoryPostProcessor</code> 分为不同的类别：</p><ul><li>实现 <code>PriorityOrdered</code> 的 <code>BeanFactoryPostProcessor</code> 会先执行。</li><li>实现 <code>Ordered</code> 的 <code>BeanFactoryPostProcessor</code> 会接着执行。</li><li>普通的 <code>BeanFactoryPostProcessor</code> 最后执行。</li></ul></li><li><p><code>ConfigurationClassPostProcessor</code> 通常属于实现 <code>PriorityOrdered</code> 的处理器，会较早执行。</p></li><li><p>自定义的 <code>customBeanFactoryPostProcessor</code> 通常是普通的 <code>BeanFactoryPostProcessor</code>，会在 <code>ConfigurationClassPostProcessor</code> 等 <code>PriorityOrdered</code> 或 <code>Ordered</code> 的处理器之后执行。</p></li></ul><h1 id="七、Spring-Bean-的初始化和销毁"><a href="#七、Spring-Bean-的初始化和销毁" class="headerlink" title="七、Spring Bean 的初始化和销毁"></a>七、Spring Bean 的初始化和销毁</h1><hr><p>Spring 提供了多种初始化手段，除了 @PostConstruct，@Bean(initMethod) 之外，还可以实现 InitializingBean 接口来进行初始化，如果同一个 bean 用了以上手段声明了 3 个初始化方法，那么它们的执行顺序是：</p><ol><li>@PostConstruct 标注的初始化方法；</li><li>InitializingBean 接口的初始化方法；</li><li>@Bean(initMethod) 指定的初始化方法；</li></ol><p>与初始化类似，Spring 也提供了多种<strong>销毁</strong>手段，执行顺序为：</p><ol><li>@PreDestroy 标注的销毁方法</li><li>DisposableBean 接口的销毁方法</li><li>@Bean(destroyMethod) 指定的销毁方法</li></ol><h1 id="八、Scope"><a href="#八、Scope" class="headerlink" title="八、Scope"></a>八、Scope</h1><hr><p><img src="/static/Hxctb96R3osTDKxD0GfcWIBonnb.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;【Spring-核心】①Spring-容器和-Bean&quot;&gt;&lt;a href=&quot;#【Spring-核心】①Spring-容器和-Bean&quot; class=&quot;headerlink&quot; title=&quot;【Spring 核心】①Spring 容器和 Bean&quot;&gt;&lt;/a&gt;【Spri</summary>
      
    
    
    
    
    <category term="backend" scheme="https://tomorrowllbefine.github.io/tags/backend/"/>
    
  </entry>
  
  <entry>
    <title>Spring核心 | ①Spring BeanFactory详解</title>
    <link href="https://tomorrowllbefine.github.io/2025/01/10/%E3%80%90Spring%E6%A0%B8%E5%BF%83%E3%80%91%E2%91%A0Spring%E5%AE%B9%E5%99%A8%E5%92%8CBean/"/>
    <id>https://tomorrowllbefine.github.io/2025/01/10/%E3%80%90Spring%E6%A0%B8%E5%BF%83%E3%80%91%E2%91%A0Spring%E5%AE%B9%E5%99%A8%E5%92%8CBean/</id>
    <published>2025-01-10T07:44:26.000Z</published>
    <updated>2025-01-10T08:09:13.674Z</updated>
    
    <content type="html"><![CDATA[<h2 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h2><blockquote><p><strong>BeanFactory 实现类：</strong>&#x63D0;供 IOC、DI、Bean 生命周期各种功能实现</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DefaultSingletonBeanRegistry.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultSingletonBeanRegistry</span> <span class="keyword">extends</span> <span class="title class_">SimpleAliasRegistry</span> <span class="keyword">implements</span> <span class="title class_">SingletonBeanRegistry</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>(<span class="number">256</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DefaultSingletonBeanRegistry</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><div style="text-align: center;">    <img src="https://raw.githubusercontent.com/Tomorrowllbefine/Study/master/pics/image-14.png" width="80%" height="80%"></div><br><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringBootDemoApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException &#123;</span><br><span class="line">        <span class="comment">// 获取Spring上下文</span></span><br><span class="line">        <span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> SpringApplication.run(SpringBootDemoApplication.class, args);</span><br><span class="line">        <span class="comment">// 通过反射：获取Spring容器中单例对象集合字段(私有)</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">singletonObjects</span> <span class="operator">=</span> DefaultSingletonBeanRegistry.class.getDeclaredField(<span class="string">&quot;singletonObjects&quot;</span>);</span><br><span class="line">        singletonObjects.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">// 获取容器beanFactory</span></span><br><span class="line">        <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> context.getBeanFactory();</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Object&gt; map = (Map&lt;String, Object&gt;) singletonObjects.get(beanFactory);</span><br><span class="line">        map.entrySet().stream().filter(e -&gt; e.getKey().startsWith(<span class="string">&quot;component&quot;</span>))</span><br><span class="line">                .forEach(e -&gt; &#123;</span><br><span class="line">                    System.out.println(e.getKey() + <span class="string">&quot; -- &quot;</span> + e.getValue());</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">component1 -- com.example.springbootdemo.service.Bean1@a22c4d8</span><br><span class="line">component2 -- com.example.springbootdemo.service.Bean2@<span class="number">45</span>cd7bc5</span><br></pre></td></tr></table></figure><br><h2 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h2><p><img src="https://raw.githubusercontent.com/Tomorrowllbefine/Study/master/pics/image-12.png"></p><blockquote><p><strong>国际化能力</strong>：能将不同的语言根据指定内容进行翻译；</p></blockquote><blockquote><p><em>context.getMessage() 方法</em></p></blockquote><p><img src="/images/image.png"></p><blockquote><p><strong>获取环境变量</strong>；</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// EnvironmentCapable.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EnvironmentCapable</span> &#123;</span><br><span class="line">    Environment <span class="title function_">getEnvironment</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>根据通配符获取资源</strong>；</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ResourcePatternResolver.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ResourcePatternResolver</span> <span class="keyword">extends</span> <span class="title class_">ResourceLoader</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">CLASSPATH_ALL_URL_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;classpath*:&quot;</span>;</span><br><span class="line"></span><br><span class="line">    Resource[] getResources(String locationPattern) <span class="keyword">throws</span> IOException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取类路径下的application.properties文件</span></span><br><span class="line">Resource[] resources = context.getResources(<span class="string">&quot;classpath:application.properties&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">    System.out.println(resource);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取所有classpath下的spring.factories文件</span></span><br><span class="line">resources = context.getResources(<span class="string">&quot;classpath*:spring.factories&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">    System.out.println(resource);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取环境变量</span></span><br><span class="line">System.out.println(context.getEnvironment().getProperty(<span class="string">&quot;java_home&quot;</span>));</span><br><span class="line">System.out.println(context.getEnvironment().getProperty(<span class="string">&quot;server.port&quot;</span>));</span><br></pre></td></tr></table></figure><blockquote><p><strong>事件发布与监听功能</strong></p></blockquote><p>基于<strong>发布-订阅模式</strong>，通过 <code>ApplicationEvent</code> 和 <code>ApplicationListener</code> 来实现。</p><p>Spring 的事件机制鼓励监听器作为 Spring Bean 注册，但并不是强制性的</p><p><strong>&gt;&gt; 定义事件类，需继承 ApplicationEvent 类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基础事件类，用于封装事件源和消息内容。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> limoukun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2024/12/26</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BaseEvent</span> <span class="keyword">extends</span> <span class="title class_">ApplicationEvent</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Serial</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BaseEvent</span><span class="params">(Object source, String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(source);</span><br><span class="line">        <span class="built_in">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>&gt;&gt; 测试调用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发布事件消息</span></span><br><span class="line"><span class="comment">// param1: Object - 源bean对象</span></span><br><span class="line">context.publishEvent(<span class="keyword">new</span> <span class="title class_">BaseEvent</span>(<span class="string">&quot;null&quot;</span>, <span class="string">&quot;测试事件消息&quot;</span>));</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component(&quot;component1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean1</span> &#123;</span><br><span class="line"></span><br><span class="line">    String value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenBaseEvent</span><span class="params">(BaseEvent event)</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;Bean1 接收到事件：&#123;&#125;&quot;</span>, event.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><em>监听的方法可以任何一个 bean 中实现；</em></p></blockquote><p><strong>&gt;&gt; 测试结果</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2024</span><span class="number">-12</span><span class="number">-26</span>T11:<span class="number">33</span>:<span class="number">16.840</span><span class="number">+0</span>8:<span class="number">00</span>  INFO <span class="number">24684</span> --- [main] c.example.springbootdemo.service.Bean1   : Bean1 接收到事件：测试事件消息</span><br></pre></td></tr></table></figure><h3 id="Q：对于用户注册和短信发送功能，使用-AOP-实现，比较与事件发布监听模型相比的区别？"><a href="#Q：对于用户注册和短信发送功能，使用-AOP-实现，比较与事件发布监听模型相比的区别？" class="headerlink" title="Q：对于用户注册和短信发送功能，使用 AOP 实现，比较与事件发布监听模型相比的区别？"></a>Q：对于用户注册和短信发送功能，使用 AOP 实现，比较与事件发布监听模型相比的区别？</h3><hr><p>使用 AOP 可以很好地解耦用户注册和短信发送功能，将短信发送的逻辑从注册功能中分离出来，使代码更清晰、更具扩展性。</p><p>分别为两个服务定义对应的实现方法，在切面中调用用户注册逻辑，并为其添加后置通知，在通知中调用短信发送逻辑。<strong>只有在切面中的逻辑执行完成（即用户成功注册），才会在后置通知中调用短信发送逻辑</strong>。</p><blockquote><p><strong>与事件发布-监听模型相比</strong></p></blockquote><p><img src="/images/image-10.png"></p><blockquote><p><strong>适用场景</strong></p></blockquote><p><strong>AOP 适用场景</strong>：</p><ul><li><p>简单逻辑：适合在目标方法执行后直接附加一段逻辑，如日志记录、性能监控等；</p></li><li><p>代码侵入少：目标方法不需要额外操作，关注点较为单一；</p></li><li><p>性能优先：逻辑简单且需要同步执行，可以避免复杂事件模型的开销；</p></li></ul><p><strong>事件发布-监听模型使用场景</strong>：</p><ul><li><p>复杂的业务流程：如注册后需要同时发送短信、邮件、写日志等多个操作；</p></li><li><p>动态扩展需求：可能在未来添加新的监听器，响应更多事件；</p></li><li><p>异步需求：需要监听器进行异步处理，如高并发下的短信、邮件发送业务；</p></li></ul><h1 id="二、容器实现"><a href="#二、容器实现" class="headerlink" title="二、容器实现"></a>二、容器实现</h1><h2 id="2-1-的实现"><a href="#2-1-的实现" class="headerlink" title="2.1 &lt;&lt;BeanFactory&gt;&gt; 的实现"></a>2.1 &lt;&lt;BeanFactory&gt;&gt; 的实现</h2><blockquote><p><strong>BeanFactory 的后置处理器</strong></p></blockquote><p>BeanFactory 需要手动调用 <strong>BeanFactory 的后置处理器</strong>进行增强</p><ul><li>如通过解析 @Bean、@ComponentScan 等注解，补充了对 bean 的定义；</li></ul><blockquote><p><strong>*原始</strong>：@Configuration；*</p><p><strong>*补充</strong>：@Bean 、@ComponentScan 等；*</p></blockquote><p><img src="https://raw.githubusercontent.com/Tomorrowllbefine/Study/master/pics/image-13.png"></p><blockquote><p><strong>Bean 的后置处理器</strong></p></blockquote><p>BeanFactory 需要手动添加 <strong>Bean 的后置处理器</strong>，以便对后续 Bean 的创建过程提供增强</p><ul><li><p>如@AutoWired、@Resource 等注解的解析都是 Bean 后置处理器完成；</p></li><li><p>Bean 后处理器的添加顺序会对解析结果有影响；</p></li></ul><blockquote><p><strong>*补充</strong>：@AutoWired、@Resource*</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试 - BeanFactory</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> limoukun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2024/12/26</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestBeanFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DefaultListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultListableBeanFactory</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// bean 的定义：class、scope、初始化方式、销毁方式等</span></span><br><span class="line">        <span class="type">AbstractBeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> BeanDefinitionBuilder.genericBeanDefinition(Config.class)</span><br><span class="line">                .setScope(<span class="string">&quot;singleton&quot;</span>)</span><br><span class="line">                .getBeanDefinition();</span><br><span class="line">        beanFactory.registerBeanDefinition(<span class="string">&quot;config&quot;</span>, beanDefinition);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为 BeanFactory 添加常用的后置处理器</span></span><br><span class="line"><span class="comment">//        AnnotationConfigUtils.registerAnnotationConfigProcessors(beanFactory);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(String beanName : beanFactory.getBeanDefinitionNames())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;beanName - &quot;</span> + beanName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Configuration</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Config</span>&#123;</span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="keyword">public</span> Bean1 <span class="title function_">bean1</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bean1</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="keyword">public</span> Bean2 <span class="title function_">bean2</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bean2</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>后处理器的排序问题</strong></p></blockquote><blockquote><p><strong>总结</strong></p></blockquote><p>&gt;&gt; BeanFactory 不会做的事：</p><ol><li><p>不会主动调用 BeanFactory 后置处理器；</p></li><li><p>不会主动添加 Bean 后处理器；</p></li><li><p>不会主动初始化单例；</p></li><li><p>不会解析 BeanFactory；</p></li><li><p>不会解析 <code>$&#123;&#125;</code> 和 <code>#&#123;&#125;</code>；</p></li></ol><br><p>&gt;&gt; Bean 的后置处理器有排序逻辑；</p><p>关于主动初始化单例，BeanFactory 中默认是<strong>懒汉式初始化</strong>，因此如果需要在编译期间就进行初始化，需要主动调用<code>preInstantiateSingletons()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (String beanName : beanFactory.getBeanDefinitionNames()) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;beanName - &quot;</span> + beanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开启饿汉式初始化实例</span></span><br><span class="line">beanFactory.preInstantiateSingletons();</span><br><span class="line">System.out.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 编译期 -&gt; 执行期 &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>);</span><br><span class="line">System.out.println(beanFactory.getBean(Bean1.class).getBean2());</span><br></pre></td></tr></table></figure><p>输出结果，左-未注释，右-注释：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">beanName - bean1</span><br><span class="line">beanName - bean2</span><br><span class="line"><span class="number">15</span>:<span class="number">57</span>:<span class="number">24.066</span> [main] INFO com.example.springbootdemo.study.beanFactory.TestBeanFactory -- Bean1 构造方法执行</span><br><span class="line"><span class="number">15</span>:<span class="number">57</span>:<span class="number">24.075</span> [main] INFO com.example.springbootdemo.study.beanFactory.TestBeanFactory -- Bean2 构造方法执行</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 编译期 -&gt; 执行期 &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">com.example.springbootdemo.study.beanFactory.TestBeanFactory$Bean2@<span class="number">7</span>c6908d7</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">beanName - bean1</span><br><span class="line">beanName - bean2</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 编译期 -&gt; 执行期 &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line"><span class="number">16</span>:<span class="number">06</span>:<span class="number">34.047</span> [main] INFO com.example.springbootdemo.study.beanFactory.TestBeanFactory -- Bean1 构造方法执行</span><br><span class="line"><span class="number">16</span>:<span class="number">06</span>:<span class="number">34.057</span> [main] INFO com.example.springbootdemo.study.beanFactory.TestBeanFactory -- Bean2 构造方法执行</span><br><span class="line">com.example.springbootdemo.study.beanFactory.TestBeanFactory$Bean2@<span class="number">477</span>b4cdf</span><br></pre></td></tr></table></figure><h2 id="2-2-的实现"><a href="#2-2-的实现" class="headerlink" title="2.2 &lt;&lt;ApplicationContext&gt;&gt; 的实现"></a>2.2 &lt;&lt;ApplicationContext&gt;&gt; 的实现</h2><ol><li><p>ClassPathXmlApplicationContext；</p></li><li><p>FileSystemXmlApplicationContext；</p></li><li><p>基于 Java 配置类创建容器，AnnotationConfigApplicationContext；</p></li></ol><blockquote><ul><li><p><em>会将带有@Configuration 注解的类注入，可以在其中配置更多的自定义 Bean；</em></p></li><li><p><em>同时，会将前文叙述的 5 个后置处理器类也注入容器；</em></p></li><li><p><em>其作用，就是 xml 配置中的<code>&lt;context:annotation-config/&gt;</code></em></p></li></ul></blockquote><ul><li>基于 SpringBoot 中 Servlet Web 环境容器，AnnotationConfigServletWebServerApplicationContext；</li></ul><blockquote><p><em>另外要注意的是，后面这些带有 ApplicationContext 的类都是 ApplicationContext 接口的实现，但它们是<strong>组合</strong>了 DefaultListableBeanFactory 的功能，并非继承而来</em></p></blockquote><h3 id="Q：关于与？"><a href="#Q：关于与？" class="headerlink" title="Q：关于&lt;context:annotation-config&#x2F;&gt;与&lt;context:component-scan&gt;？"></a>Q：关于&lt;context:annotation-config&#x2F;&gt;与&lt;context:component-scan&gt;？</h3><hr><blockquote><p><em><strong>参考好文</strong>：<a href="https://stackoverflow.com/questions/7414794/difference-between-contextannotation-config-and-contextcomponent-scan%EF%BC%9B">https://stackoverflow.com/questions/7414794/difference-between-contextannotation-config-and-contextcomponent-scan；</a></em></p></blockquote><p>基础功能，提供对 XML 中自定义 Bean 的注入，同时支持对 Bean 定义注解@AutoWried 等的处理；</p><p>后者，相对于前者多了对指定包路径的扫描，以达到对指定的 Bean 的注入；</p><p><strong>底层原理</strong>：都是通过添加 BeanFactory 的后置处理器，来实现对除了@Configuration 以外的 Bean 定义注解的识别、解析和处理；</p><blockquote><p><em><strong>Chat 老师</strong>：</em></p></blockquote><p><strong><code>&lt;context:annotation-config&gt;</code> 的作用</strong></p><ul><li><p>该标签的主要功能是启用 Spring 的注解驱动功能，例如支持 <code>@Autowired</code>、<code>@Resource</code>、<code>@PostConstruct</code>、<code>@PreDestroy</code> 等注解的处理。</p></li><li><p>它并不会扫描包路径，也就是说，<strong>只作用于已经通过 XML 或其他方式显式注册到 Spring 容器中的 Bean</strong>。</p></li></ul><p><strong><code>&lt;context:component-scan&gt;</code> 的作用</strong></p><ul><li><p>它不仅包含了 <code>&lt;context:annotation-config&gt;</code> 的功能，还额外实现了自动扫描指定包路径下的组件（如 <code>@Component</code>、<code>@Repository</code>、<code>@Service</code>、<code>@Controller</code> 等注解标记的类），并将它们注册为 Spring 容器中的 Bean。</p></li><li><p>如果使用了 <code>&lt;context:component-scan&gt;</code>，就不需要单独声明 <code>&lt;context:annotation-config&gt;</code>，因为前者已经隐式地包含了后者的功能。</p></li></ul><p><strong>底层原理</strong></p><ul><li><p>两者都依赖于 Spring 的 <code>BeanFactoryPostProcessor</code>，主要通过 <code>ConfigurationClassPostProcessor</code> 来解析相关注解（例如 <code>@Autowired</code>）并将这些注解的元信息存储在容器中。</p></li><li><p>对于 <code>&lt;context:component-scan&gt;</code>，还会触发 <code>ClassPathBeanDefinitionScanner</code> 进行包扫描，并根据指定的注解（如 <code>@Component</code>）自动创建 <code>BeanDefinition</code> 并注册到容器。</p></li></ul><p><strong>总结两者的区别</strong></p><ul><li><p><code>&lt;context:annotation-config&gt;</code>：启用注解驱动功能，作用于已定义的 Bean。</p></li><li><p><code>&lt;context:component-scan&gt;</code>：在启用注解驱动功能的基础上，增加了自动扫描和注册的能力。</p></li></ul><p>此外，对于如下三个内部类（后置处理器），Spring 会通过 <code>AnnotationConfigUtils</code> 自动注册这三个（以及其他一些内部的 BeanPostProcessor 和 BeanFactoryPostProcessor）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.context.annotation.internalConfigurationAnnotationProcessor</span><br><span class="line">org.springframework.context.annotation.internalAutowiredAnnotationProcessor</span><br><span class="line">org.springframework.context.annotation.internalCommonAnnotationProcessor</span><br></pre></td></tr></table></figure><ul><li><p>使用 <code>&lt;context:annotation-config&gt;</code> 或 <code>&lt;context:component-scan&gt;</code>，Spring 会自动注册 **<code>internalConfigurationAnnotationProcessor</code>**，从而启用对 <code>@Configuration</code> 和其他相关注解的处理。</p></li><li><p>使用 <code>&lt;context:annotation-config&gt;</code> 或 <code>&lt;context:component-scan&gt;</code> 时，Spring 会自动注册 **<code>internalAutowiredAnnotationProcessor</code>**，确保容器中的 Bean 能正确解析 <code>@Autowired</code> 等注解。</p></li><li><p>使用 <code>&lt;context:annotation-config&gt;</code> 或 <code>&lt;context:component-scan&gt;</code> 时，Spring 会自动注册 **<code>internalCommonAnnotationProcessor</code>**，确保容器中的 Bean 能正确解析 <code>@Resource</code> 等注解</p></li></ul><h3 id="2-2-x-AnnotationConfigServletWebServerApplicationContext"><a href="#2-2-x-AnnotationConfigServletWebServerApplicationContext" class="headerlink" title="2.2.x AnnotationConfigServletWebServerApplicationContext"></a>2.2.x AnnotationConfigServletWebServerApplicationContext</h3><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试 - ApplicationContext的基本实现类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> limoukun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2024/12/27</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application_01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigServletWebServerApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">AnnotationConfigServletWebServerApplicationContext</span>(WebConfig.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Configuration</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> &#123;</span><br><span class="line">        <span class="comment">// 内嵌Tomcat服务器</span></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="keyword">public</span> ServletWebServerFactory <span class="title function_">servletWebServerFactory</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TomcatServletWebServerFactory</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Dispatcher分发Servlet</span></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="keyword">public</span> DispatcherServlet <span class="title function_">dispatcherServlet</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DispatcherServlet</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绑定 将Dispatcher装载在Tomcat上</span></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="keyword">public</span> DispatcherServletRegistrationBean <span class="title function_">registrationBean</span><span class="params">(DispatcherServlet dispatcherServlet)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DispatcherServletRegistrationBean</span>(dispatcherServlet, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 控制器</span></span><br><span class="line">        <span class="meta">@Bean(&quot;/hello&quot;)</span></span><br><span class="line">        <span class="keyword">public</span> Controller <span class="title function_">controller</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Controller</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> ModelAndView <span class="title function_">handleRequest</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    response.getWriter().println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong>：</p><p><img src="/images/image-8.png"></p><h1 id="三、Bean-生命周期"><a href="#三、Bean-生命周期" class="headerlink" title="三、Bean 生命周期"></a>三、Bean 生命周期</h1><hr><p>根据 Bean 的一些关键节点方法测试生命周期：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application_02</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> SpringApplication.run(Application_02.class, args);</span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试 - 生命周期Bean</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> limoukun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2024/12/27</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LifeCycleBean</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LifeCycleBean</span><span class="params">()</span> &#123;log.debug(<span class="string">&quot;构造方法...&quot;</span>);&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 值注入JAVA_HOME</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">autowire</span><span class="params">(<span class="meta">@Value(&quot;$&#123;java_home&#125;&quot;)</span> String home)</span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;依赖注入:&#123;&#125;&quot;</span>, home);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bean的初始化方法</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;初始化...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bean的销毁方法</span></span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;销毁...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">构造方法...</span><br><span class="line">依赖注入:D:\JAVA8</span><br><span class="line">初始化...</span><br><span class="line"><span class="number">2024</span><span class="number">-12</span><span class="number">-27</span>T20:<span class="number">58</span>:<span class="number">37.423</span><span class="number">+0</span>8:<span class="number">00</span>  INFO <span class="number">17156</span> --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : <span class="function">Tomcat started on <span class="title">port</span><span class="params">(s)</span>: <span class="number">8088</span> (http) with context path <span class="string">&#x27;&#x27;</span></span></span><br><span class="line"><span class="string"><span class="function">2024-12-27T20:58:37.428+08:00  INFO 17156 --- [           main] c.e.s.s.s.Application_02                 : Started Application_02 in 1.177 seconds (process running for 1.649)</span></span></span><br><span class="line"><span class="string"><span class="function">2024-12-27T20:58:37.446+08:00  INFO 17156 --- [           main] o.apache.catalina.core.StandardService   : Stopping service [Tomcat]</span></span></span><br><span class="line"><span class="string"><span class="function">销毁...</span></span></span><br></pre></td></tr></table></figure><p><img src="/images/image-7.png"></p><p><img src="https://raw.githubusercontent.com/Tomorrowllbefine/Study/master/pics/image-11.png"></p><blockquote><p><em>实例化 —— 调用对象的<code>Ctor()</code>方法；</em></p><p><em>初始化 —— 调用 Spring Bean 的<code>init()</code>方法；</em></p></blockquote><blockquote><p><strong>Bean 的生命周期 —— 五步骤</strong></p></blockquote><ol><li><p>对象实例化；</p></li><li><p>依赖注入；</p></li><li><p>Bean 的初始化；</p></li><li><p>Bean 的使用；</p></li><li><p>Bean 的销毁；</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2024</span><span class="number">-12</span><span class="number">-28</span>T09:<span class="number">17</span>:<span class="number">52.652</span><span class="number">+0</span>8:<span class="number">00</span> DEBUG <span class="number">28240</span> --- [main] c.e.s.s.s.LifeCycleBean                  : 构造方法...</span><br><span class="line"><span class="number">2024</span><span class="number">-12</span><span class="number">-28</span>T09:<span class="number">17</span>:<span class="number">52.654</span><span class="number">+0</span>8:<span class="number">00</span> DEBUG <span class="number">28240</span> --- [main] c.e.s.s.s.LifeCycleBean                  : 依赖注入:D:\JAVA8</span><br><span class="line"><span class="number">2024</span><span class="number">-12</span><span class="number">-28</span>T09:<span class="number">17</span>:<span class="number">52.655</span><span class="number">+0</span>8:<span class="number">00</span> DEBUG <span class="number">28240</span> --- [main] c.e.s.s.s.LifeCycleBean                  : 初始化...</span><br><span class="line"><span class="number">2024</span><span class="number">-12</span><span class="number">-28</span>T09:<span class="number">17</span>:<span class="number">52.871</span><span class="number">+0</span>8:<span class="number">00</span>  INFO <span class="number">28240</span> --- [main] o.s.b.w.embedded.tomcat.TomcatWebServer  : <span class="function">Tomcat started on <span class="title">port</span><span class="params">(s)</span>: <span class="number">8088</span> (http) with context path <span class="string">&#x27;&#x27;</span></span></span><br><span class="line"><span class="string"><span class="function">2024-12-28T09:17:52.877+08:00  INFO 28240 --- [main] c.e.s.s.s.Application_02                 : Started Application_02 in 1.168 seconds (process running for 1.59)</span></span></span><br><span class="line"><span class="string"><span class="function">2024-12-28T09:17:52.878+08:00 DEBUG 28240 --- [main] c.e.s.s.s.Application_02                 : 使用Bean - com.example.springbootdemo.study.s03_bean_lifecycle.LifeCycleBean@5f95f1e1</span></span></span><br><span class="line"><span class="string"><span class="function">2024-12-28T09:17:52.896+08:00  INFO 28240 --- [main] o.apache.catalina.core.StandardService   : Stopping service [Tomcat]</span></span></span><br><span class="line"><span class="string"><span class="function">2024-12-28T09:17:52.902+08:00 DEBUG 28240 --- [main] c.e.s.s.s.LifeCycleBean                  : 销毁...</span></span></span><br></pre></td></tr></table></figure><blockquote><p><em>后续的扩展点都是基于这<strong>基本的 5 步骤</strong>进行的追加后置处理器；</em></p></blockquote><blockquote><p><strong>Bean 的生命周期 —— 十一步骤</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 类对象实例化前 postProcessBeforeInstantiation - 后置处理器...</span><br><span class="line">Ctor 构造方法...</span><br><span class="line">&lt;&lt;&lt; 类对象实例化后 postProcessAfterInstantiation - 后置处理器...</span><br><span class="line">+++ 依赖注入阶段 postProcessProperties - 后置处理器，对@Autowired、@Resource等注解解析...</span><br><span class="line">@Autowired 依赖注入:D:\JAVA8</span><br><span class="line">&gt;&gt;&gt; Bean初始化前 postProcessBeforeInitialization - 后置处理器，此处返回的对象会替换原本的Bean...</span><br><span class="line">@PostConstruct 初始化...</span><br><span class="line">+++ Bean初始化后 afterPropertiesSet - 后置处理器...</span><br><span class="line">&lt;&lt;&lt; Bean初始化后 postProcessAfterInitialization - 后置处理器，此处返回的对象会替换原本的Bean，如代理增强...</span><br><span class="line"><span class="function">Tomcat started on <span class="title">port</span><span class="params">(s)</span>: <span class="number">8088</span> (http) with context path <span class="string">&#x27;&#x27;</span></span></span><br><span class="line"><span class="string"><span class="function">Started Application_02 in 1.133 seconds (process running for 1.475)</span></span></span><br><span class="line"><span class="string"><span class="function">使用Bean - com.example.springbootdemo.study.s03_bean_lifecycle.LifeCycleBean@7e72a6cc</span></span></span><br><span class="line"><span class="string"><span class="function">Stopping service [Tomcat]</span></span></span><br><span class="line"><span class="string"><span class="function">@PreDestroy 销毁...</span></span></span><br></pre></td></tr></table></figure><h1 id="四、Bean-后置处理器"><a href="#四、Bean-后置处理器" class="headerlink" title="四、Bean 后置处理器"></a>四、Bean 后置处理器</h1><p>常见的 <code>@Autowired</code> 等注解的解析属于 bean 生命周期阶段（依赖注入、初始化）的扩展功能，这些扩展功能可以由 Bean 后置处理器完成。</p><p>常见的 Bean 后置处理器所增强的功能：</p><ul><li><p>AutowiredAnnotationBeanPostProcessor 解析 <code>@Autowired</code> 与 <code>@Value</code>；</p></li><li><p>CommonAnnotationBeanPostProcessor 解析 <code>@Resource</code>、<code>@PostConstruct</code>、<code>@PreDestroy</code>；</p></li><li><p>ConfigurationPropertiesBindingPostProcessor 解析 <code>@ConfigurationProperties</code>；</p></li><li><p>ContextAnnotationAutowireCandidateResolver 负责获取 <code>@Value</code> 的值，解析 <code>@Qualifier</code>、泛型、<code>@Lazy</code> 等；</p></li></ul><h2 id="4-1-Autowired-Bean-后置处理器"><a href="#4-1-Autowired-Bean-后置处理器" class="headerlink" title="4.1 @Autowired Bean 后置处理器"></a>4.1 @Autowired Bean 后置处理器</h2><p>通过<strong>反射</strong>对创建的<code>AutowiredAnnotationBeanPostProcessor</code>后置处理器进行调用，分析@Autowired 的后置处理器的执行原理。</p><p><strong>&gt;&gt; Bean 间的依赖关系</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">Slf4j</span>(topic = <span class="string">&quot;Bean1.java&quot;</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Bean2 bean2;</span><br><span class="line">    <span class="comment">// @Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Bean3 bean3;</span><br><span class="line">    <span class="keyword">private</span> String javaHome;</span><br><span class="line"></span><br><span class="line">    @<span class="function">Autowired</span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="type">void</span> <span class="title">setBean2</span><span class="params">(Bean2 bean2)</span> </span>&#123;</span><br><span class="line">        log.<span class="built_in">info</span>(<span class="string">&quot;@Autowired 生效 &#123;&#125;&quot;</span>, bean2);</span><br><span class="line">        <span class="keyword">this</span>.bean2 = bean2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @<span class="function">Resource</span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="type">void</span> <span class="title">setBean3</span><span class="params">(Bean3 bean3)</span> </span>&#123;</span><br><span class="line">        log.<span class="built_in">info</span>(<span class="string">&quot;@Resource 生效 &#123;&#125;&quot;</span>, bean3);</span><br><span class="line">        <span class="keyword">this</span>.bean3 = bean3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @<span class="function">Autowired</span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="type">void</span> <span class="title">setJavaHome</span><span class="params">(@Value(<span class="string">&quot;$&#123;java_home&#125;&quot;</span>) String javaHome)</span> </span>&#123;</span><br><span class="line">        log.<span class="built_in">info</span>(<span class="string">&quot;@Value 生效 &#123;&#125;&quot;</span>, javaHome);</span><br><span class="line">        <span class="keyword">this</span>.javaHome = javaHome;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @<span class="function">PostConstruct</span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.<span class="built_in">info</span>(<span class="string">&quot;@PostConstruct 生效&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @<span class="function">PreDestroy</span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="type">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.<span class="built_in">info</span>(<span class="string">&quot;@PreDestroy 生效&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @<span class="function">Override</span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Bean1&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;bean2=&quot;</span> + bean2 +</span><br><span class="line">                <span class="string">&quot;, bean3=&quot;</span> + bean3 +</span><br><span class="line">                <span class="string">&quot;, javaHome=&#x27;&quot;</span> + javaHome + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>&gt;&gt; 分析和验证 AutowiredAnnotationBeanPostProcessor 执行流程</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分析 - AutowiredAnnotationBeanPostProcessor 执行流程</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> limoukun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2024/12/28</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DigInAutowired</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">DefaultListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultListableBeanFactory</span>();</span><br><span class="line"></span><br><span class="line">        beanFactory.registerSingleton(<span class="string">&quot;bean2&quot;</span>, <span class="keyword">new</span> <span class="title class_">Bean2</span>());</span><br><span class="line">        beanFactory.registerSingleton(<span class="string">&quot;bean3&quot;</span>, <span class="keyword">new</span> <span class="title class_">Bean3</span>());</span><br><span class="line">        processor.setBeanFactory(beanFactory); <span class="comment">// @Value</span></span><br><span class="line">        beanFactory.addEmbeddedValueResolver(<span class="keyword">new</span> <span class="title class_">StandardEnvironment</span>()::resolvePlaceholders); <span class="comment">// $&#123;&#125; 的解析器</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建后置处理器AutowiredAnnotationBeanPostProcessor</span></span><br><span class="line">        <span class="type">AutowiredAnnotationBeanPostProcessor</span> <span class="variable">processor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AutowiredAnnotationBeanPostProcessor</span>();</span><br><span class="line">        processor.setBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">        <span class="type">Bean1</span> <span class="variable">bean1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bean1</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;手动注入@Autowired前:&quot;</span> + bean1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过反射获取AutowiredAnnotationBeanPostProcessor的两个主要方法</span></span><br><span class="line">        <span class="comment">// 获取findAutowiringMetadata()并调用</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">findAutowiringMetadata</span> <span class="operator">=</span> AutowiredAnnotationBeanPostProcessor.class.</span><br><span class="line">                getDeclaredMethod(<span class="string">&quot;findAutowiringMetadata&quot;</span>, String.class, Class.class, PropertyValues.class);</span><br><span class="line">        findAutowiringMetadata.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">InjectionMetadata</span> <span class="variable">injectionMetadata</span> <span class="operator">=</span> (InjectionMetadata) findAutowiringMetadata.invoke(processor, <span class="string">&quot;bean1&quot;</span>, Bean1.class, <span class="literal">null</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;injectionMetadata:&quot;</span> + injectionMetadata);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用injectionMetadata.inject()进行注入</span></span><br><span class="line">        injectionMetadata.inject(bean1, <span class="string">&quot;bean1&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;手动注入@Autowired后:&quot;</span> + bean1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>&gt;&gt; 输出结果</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">手动注入@Autowired前:Bean1&#123;bean2=null, bean3=null, javaHome=<span class="string">&#x27;null&#x27;</span>&#125;</span><br><span class="line">injectionMetadata:org.springframework.beans.factory.annotation.InjectionMetadata@<span class="number">442675e1</span></span><br><span class="line"><span class="number">10</span>:<span class="number">18</span>:<span class="number">03.563</span> [main] INFO Bean<span class="number">1.</span>java -- @Autowired 生效 com.example.springbootdemo.study.s04_bean_postprocessor.Bean2@<span class="number">77e9807f</span></span><br><span class="line"><span class="number">10</span>:<span class="number">18</span>:<span class="number">03.571</span> [main] INFO Bean<span class="number">1.</span>java -- @Value 生效 D:\JAVA8</span><br><span class="line">手动注入@Autowired后:Bean1&#123;bean2=com.example.springbootdemo.study.s04_bean_postprocessor.Bean2@<span class="number">77e9807f</span>, bean3=null, javaHome=<span class="string">&#x27;D:\JAVA8&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><p>进入 debug 模式，可以看到<code>injectionMetadata</code>中存储了带有@Autowried 注解的两个 set 方法</p><p><img src="/images/image-9.png"></p><blockquote><p><strong>深入 inject() 过程</strong></p></blockquote><p>前面的例子中，在调用<code>findAutowiringMetadata()</code>方法得到了<strong>当前 Bean1 中添加了<code>@Autowired</code>注解的属性字段和方法</strong>后，将其都存入了<strong>注入元数据对象</strong><code>InjectionMetadata</code>中。</p><p>那么在后续的<code>inject()</code>中，核心的逻辑就是<strong>完成对 Bean1 的依赖注入</strong>，就是通过<strong>反射</strong>，将<strong>容器中管理的 Bean</strong>设置到 Bean1 中<strong>添加了<code>@Autowired</code>注解的属性字段和方法。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Bean2 bean2;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Bean3 bean3;</span><br><span class="line">    <span class="keyword">private</span> String javaHome;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBean2</span><span class="params">(Bean2 bean2)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;@Autowired 生效 &#123;&#125;&quot;</span>, bean2);</span><br><span class="line">        <span class="built_in">this</span>.bean2 = bean2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBean3</span><span class="params">(Bean3 bean3)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;@Resource 生效 &#123;&#125;&quot;</span>, bean3);</span><br><span class="line">        <span class="built_in">this</span>.bean3 = bean3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setJavaHome</span><span class="params">(<span class="meta">@Value(&quot;$&#123;java_home&#125;&quot;)</span> String javaHome)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;@Value 生效 &#123;&#125;&quot;</span>, javaHome);</span><br><span class="line">        <span class="built_in">this</span>.javaHome = javaHome;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据上述 Bean1.java 的类定义，可归纳出如下过程图：</p><p><img src="/images/image-6.png" alt="图 AutowiredAnnotationBeanPostProcessor后置处理器依赖注入原理"></p><p>对上述过程进行模拟：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在得到了injectionMetadata下，如何按照注入Bean的类型查找值？</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">bean3</span> <span class="operator">=</span> Bean1.class.getDeclaredField(<span class="string">&quot;bean3&quot;</span>);</span><br><span class="line"><span class="type">DependencyDescriptor</span> <span class="variable">dd1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DependencyDescriptor</span>(bean3, <span class="literal">false</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">get_bean3</span> <span class="operator">=</span> beanFactory.doResolveDependency(dd1, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;Bean3: &quot;</span> + get_bean3);</span><br><span class="line"></span><br><span class="line"><span class="type">Method</span> <span class="variable">setBean2</span> <span class="operator">=</span> Bean1.class.getDeclaredMethod(<span class="string">&quot;setBean2&quot;</span>, Bean2.class);</span><br><span class="line"><span class="type">DependencyDescriptor</span> <span class="variable">dd2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DependencyDescriptor</span>(<span class="keyword">new</span> <span class="title class_">MethodParameter</span>(setBean2, <span class="number">0</span>), <span class="literal">false</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">get_setBean2</span> <span class="operator">=</span> beanFactory.doResolveDependency(dd2, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;Bean2: &quot;</span> + get_setBean2);</span><br><span class="line"></span><br><span class="line"><span class="type">Method</span> <span class="variable">setJavaHome</span> <span class="operator">=</span> Bean1.class.getDeclaredMethod(<span class="string">&quot;setJavaHome&quot;</span>, String.class);</span><br><span class="line"><span class="type">DependencyDescriptor</span> <span class="variable">dd3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DependencyDescriptor</span>(<span class="keyword">new</span> <span class="title class_">MethodParameter</span>(setJavaHome, <span class="number">0</span>), <span class="literal">false</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">get_setJavaHome</span> <span class="operator">=</span> beanFactory.doResolveDependency(dd3, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;Value(\&quot;$&#123;java_home&#125;\&quot;): &quot;</span> + get_setJavaHome);</span><br></pre></td></tr></table></figure><p><strong>分析</strong>：</p><ol><li><p><strong>通过 <code>DependencyDescriptor</code> 描述注入点：</strong><code>DependencyDescriptor</code> 是 Spring 用于描述依赖注入点的对象，可以是字段、方法参数等；</p></li><li><p><strong>通过 <code>doResolveDependency()</code> 解析依赖</strong>：<code>doResolveDependency</code> 是 <code>DefaultListableBeanFactory</code> 提供的方法，用于根据 <code>DependencyDescriptor</code> 和容器上下文信息解析依赖；</p><ol><li><p>检查容器中是否有符合类型的 Bean；</p></li><li><p>如果注入点上有值注解（如 <code>@Value</code>），解析占位符或默认值；</p></li><li><p>根据依赖类型、名称或限定符（<code>@Qualifier</code>）选择合适的依赖；</p></li></ol></li></ol><p><strong>注意</strong>：</p><ul><li><p>如果注入的依赖找不到，会根据 <code>DependencyDescriptor</code> 的 <code>required</code> 参数决定是否抛出异常；</p></li><li><p>如果依赖有多个候选 Bean，可以通过 <code>@Qualifier</code> 或其他限定符明确指定；</p></li><li><p>对于占位符解析，需确保 Spring 的 <code>PropertySourcesPlaceholderConfigurer</code> 正常工作；</p></li></ul><br><blockquote><p><em>在 Spring 中，<code>InjectionMetadata.inject()</code> 方法的实际作用是 <strong>对某个对象执行依赖注入操作</strong>，包括字段注入、方法注入等，通常用于实现 <code>@Autowired</code>、<code>@Value</code> 和 <code>@Resource</code> 等注解的依赖注入逻辑。</em></p><p><strong>*作用详解</strong>：*</p><ol><li><p><strong><em>注入对象中的依赖</em></strong></p><ol><li><p><em><code>InjectionMetadata.inject()</code> 会按照 <code>InjectionMetadata</code> 中保存的注入元数据，逐一对目标对象的字段和方法执行依赖注入。</em></p></li><li><p><em>该方法通常会通过反射（<code>ReflectionUtils</code>）来设置字段值或调用方法。</em></p></li></ol></li><li><p><strong><em>依赖注入的核心逻辑</em></strong></p><ol><li><p><em>解析哪些字段或方法需要注入（通过 <code>InjectionMetadata</code> 的元数据）。</em></p></li><li><p><em>对这些字段或方法执行依赖注入，将 Spring 容器中管理的 Bean 注入到目标对象中。</em></p></li></ol></li><li><p><strong><em>触发时机</em></strong></p><ol><li><em>Spring 框架在 Bean 的生命周期中（通常在初始化阶段）调用该方法，比如通过 <code>AutowiredAnnotationBeanPostProcessor</code> 或类似的 <code>BeanPostProcessor</code> 实现，执行注入逻辑。</em></li></ol></li></ol></blockquote><h3 id="Q：registerSingleton-与-registerBean-的区别？生命周期？"><a href="#Q：registerSingleton-与-registerBean-的区别？生命周期？" class="headerlink" title="Q：registerSingleton() 与 registerBean() 的区别？生命周期？"></a>Q：registerSingleton() 与 registerBean() 的区别？生命周期？</h3><hr><p><code>beanFactory.registerSingleton()</code> 和 <code>registerBean()</code> 是 Spring 框架中用于动态注册 Bean 的两种不同方式，它们的应用场景和实现方式有所不同。</p><blockquote><p><strong>beanFactory.registerSingleton(String beanName, Object singletonObject)</strong></p></blockquote><p>直接向容器注册一个已经实例化的单例对象，适用于需要直接将一个现有的对象（如某个类的实例、外部创建的对象）注册到 Spring 容器中时使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> applicationContext.getBeanFactory();</span><br><span class="line"><span class="type">MyBean</span> <span class="variable">myBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyBean</span>(); <span class="comment">// 手动创建对象</span></span><br><span class="line">beanFactory.registerSingleton(<span class="string">&quot;myBean&quot;</span>, myBean);</span><br></pre></td></tr></table></figure><p><strong>特点</strong>：</p><ul><li><p>不会经历 Spring Bean 的完整生命周期；</p></li><li><p>不需要容器参与创建，直接注入现成的对象；</p></li><li><p>无法注入原型作用域的 Bean，该方法仅支持单例 Bean；</p></li></ul><blockquote><p><em><strong>registerBean(Class&lt;?&gt; beanClass, Object… args)</strong></em></p></blockquote><p>注册一个新的 Bean 定义，Spring 容器会根据定义自动创建 Bean 实例，需要使用 Spring 提供的 <code>GenericApplicationContext</code> 类。</p><p>用于动态定义和注册 Bean，当需要完全交给 Spring 管理（包括生命周期和依赖注入）时使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">context.registerBean(MyBean.class, () -&gt; <span class="keyword">new</span> <span class="title class_">MyBean</span>(<span class="string">&quot;参数1&quot;</span>, <span class="string">&quot;参数2&quot;</span>)); <span class="comment">// 使用 Supplier 创建</span></span><br><span class="line">context.refresh();</span><br><span class="line"></span><br><span class="line"><span class="type">MyBean</span> <span class="variable">myBean</span> <span class="operator">=</span> context.getBean(MyBean.class);</span><br></pre></td></tr></table></figure><p><strong>特点</strong>：</p><ul><li><p>支持所有 Bean 作用域（单例、原型等）。</p></li><li><p>支持 Spring Bean 生命周期管理（包括初始化、销毁回调）。</p></li><li><p>需要先定义 Bean，再交给 Spring 容器实例化。</p></li></ul><p><img src="/images/image-5.png"></p><h3 id="Q：如何处理-registerSingleton-注入的-Bean-中包含有对其它-Bean-的依赖？"><a href="#Q：如何处理-registerSingleton-注入的-Bean-中包含有对其它-Bean-的依赖？" class="headerlink" title="Q：如何处理 registerSingleton()注入的 Bean 中包含有对其它 Bean 的依赖？"></a>Q：如何处理 registerSingleton()注入的 Bean 中包含有对其它 Bean 的依赖？</h3><hr><p>如果使用 <code>beanFactory.registerSingleton()</code> 手动注册了一个 <code>Bean1</code> 实例，而这个实例中有对其他 Bean（如 <code>Bean3</code>）的依赖，Spring 容器 <strong>不会自动解析和注入</strong> <code>Bean3</code>，因为 <code>registerSingleton</code> 注册的对象是已经实例化的对象，Spring 不会重新对其依赖进行注入。</p><p>解决：</p><blockquote><p><strong>手动注入</strong></p></blockquote><p>在注册 <code>Bean1</code> 前，手动从容器中获取 <code>Bean3</code> 并注入到 <code>Bean1</code> 中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> applicationContext.getBeanFactory();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手动创建 Bean1 并注入依赖</span></span><br><span class="line"><span class="type">Bean1</span> <span class="variable">bean1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bean1</span>();</span><br><span class="line"><span class="type">Bean3</span> <span class="variable">bean3</span> <span class="operator">=</span> applicationContext.getBean(Bean3.class);</span><br><span class="line">bean1.setBean3(bean3); <span class="comment">// 假设 Bean1 提供了 set 方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册 Bean1</span></span><br><span class="line">beanFactory.registerSingleton(<span class="string">&quot;bean1&quot;</span>, bean1);</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p><strong>使用 <code>@Configurable</code> 和 <code>AspectJ</code> 支持</strong></p></blockquote><p>让 <code>Bean1</code> 支持依赖注入，即使通过 <code>new</code> 创建，也能注入依赖。需要开启 Spring 的 AspectJ 支持：</p><ul><li>在配置类中启用 <code>@EnableSpringConfigured</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSpringConfigured</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>为 <code>Bean1</code> 添加 <code>@Configurable</code> 注解</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configurable</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean1</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Bean3 bean3;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getter/setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在实例化 <code>Bean1</code> 时，即使用 <code>new</code> 创建，Spring 也会为其注入 <code>Bean3</code></li></ul><blockquote><p><strong>改用<code>registerBean()</code>注入</strong></p></blockquote><h2 id="4-2-Resource-Bean-后置处理器"><a href="#4-2-Resource-Bean-后置处理器" class="headerlink" title="4.2 @Resource Bean 后置处理器"></a>4.2 @Resource Bean 后置处理器</h2><hr><h1 id="五、Bean-工厂后置处理器"><a href="#五、Bean-工厂后置处理器" class="headerlink" title="五、Bean 工厂后置处理器"></a>五、Bean 工厂后置处理器</h1><p>使用 <strong>GenericApplicationContext&#x20;</strong>&#x4E0A;下文，可以得到较为纯净的 Spring 容器，其中没有添加其它的后置处理器。</p><p>进行如下验证：</p><ul><li><p>注册 ConfigurationClassPostProcessor 后置处理器，用以处&#x7406;<strong><code>@ComponentScan</code> <code>@Bean</code> <code>@Import</code> <code>@ImportResource</code></strong>&#x6CE8;解的解析；</p></li><li><p>注册 ComponentScanner 后置处理器，用以处&#x7406;<strong><code>@Mapper</code></strong>&#x6CE8;解的解析；</p></li></ul><p><img src="/images/image-2.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.example.springbootdemo.study.s05_beanfactory_postprocessor.component&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Config</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Bean1 <span class="title function_">bean1</span><span class="params">()</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bean1</span>();&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactoryBean <span class="title function_">sqlSessionFactoryBean</span><span class="params">(DataSource dataSource)</span> &#123;</span><br><span class="line">        <span class="type">SqlSessionFactoryBean</span> <span class="variable">sqlSessionFactoryBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBean</span>();</span><br><span class="line">        sqlSessionFactoryBean.setDataSource(dataSource);</span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactoryBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(initMethod = &quot;init&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DruidDataSource <span class="title function_">druidDataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">druidDataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        druidDataSource.setUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>);</span><br><span class="line">        druidDataSource.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        druidDataSource.setPassword(<span class="string">&quot;20151109Lmk&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> druidDataSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application_04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line"></span><br><span class="line">        context.registerBean(<span class="string">&quot;config&quot;</span>, Config.class);</span><br><span class="line">        <span class="comment">// @ComponentScan @Bean @Import @ImportResource</span></span><br><span class="line">        context.registerBean(ConfigurationClassPostProcessor.class);</span><br><span class="line">        <span class="comment">// @MapperScanner</span></span><br><span class="line">        context.registerBean(MapperScannerConfigurer.class, bd -&gt; &#123;</span><br><span class="line">            bd.getPropertyValues().add(<span class="string">&quot;basePackage&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;com.example.springbootdemo.study.s05_beanfactory_postprocessor.mapper&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化容器</span></span><br><span class="line">        context.refresh();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String name : context.getBeanDefinitionNames()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;beanName - &quot;</span> + name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12</span>:<span class="number">17</span>:<span class="number">55.664</span> [main] INFO com.alibaba.druid.pool.DruidDataSource -- &#123;dataSource<span class="number">-1</span>&#125; inited</span><br><span class="line"><span class="number">12</span>:<span class="number">17</span>:<span class="number">55.711</span> [main] INFO com.example.springbootdemo.study.s05_beanfactory_postprocessor.component.Bean2 -- Bean2 被Spring管理</span><br><span class="line"><span class="number">12</span>:<span class="number">17</span>:<span class="number">55.711</span> [main] INFO com.example.springbootdemo.study.s05_beanfactory_postprocessor.Bean1 -- Bean1 被Spring管理</span><br><span class="line">beanName - config</span><br><span class="line">beanName - org.mybatis.spring.mapper.MapperScannerConfigurer</span><br><span class="line">beanName - mapper1</span><br><span class="line">beanName - mapper2</span><br><span class="line">beanName - org.springframework.context.annotation.internalConfigurationAnnotationProcessor</span><br><span class="line">beanName - org.springframework.context.annotation.internalAutowiredAnnotationProcessor</span><br><span class="line">beanName - org.springframework.context.annotation.internalCommonAnnotationProcessor</span><br><span class="line">beanName - org.springframework.context.event.internalEventListenerProcessor</span><br><span class="line">beanName - org.springframework.context.event.internalEventListenerFactory</span><br><span class="line">beanName - bean2</span><br><span class="line">beanName - bean1</span><br><span class="line">beanName - sqlSessionFactoryBean</span><br><span class="line">beanName - druidDataSource</span><br><span class="line"><span class="number">12</span>:<span class="number">17</span>:<span class="number">55.733</span> [main] INFO com.alibaba.druid.pool.DruidDataSource -- &#123;dataSource<span class="number">-1</span>&#125; closing ...</span><br><span class="line"><span class="number">12</span>:<span class="number">17</span>:<span class="number">55.734</span> [main] INFO com.alibaba.druid.pool.DruidDataSource -- &#123;dataSource<span class="number">-1</span>&#125; closed</span><br></pre></td></tr></table></figure><h3 id="Q：关于只注册了-MapperScannerConfigurer-后置处理器后与还注册了-ConfigurationClassPostProcessor-后置处理器结果一致的思考？"><a href="#Q：关于只注册了-MapperScannerConfigurer-后置处理器后与还注册了-ConfigurationClassPostProcessor-后置处理器结果一致的思考？" class="headerlink" title="Q：关于只注册了 MapperScannerConfigurer 后置处理器后与还注册了 ConfigurationClassPostProcessor 后置处理器结果一致的思考？"></a><strong>Q：关于只注册了 MapperScannerConfigurer 后置处理器后与还注册了 ConfigurationClassPostProcessor 后置处理器结果一致的思考？</strong></h3><hr><p>注册 <code>MapperScannerConfigurer</code> 时，由于它实现了 <code>BeanDefinitionRegistryPostProcessor</code>，会触发 Spring 容器的后置处理器加载流程。</p><p>因此<code>ConfigurationClassPostProcessor</code> 作为核心组件被加载，间接导致了上述内部 Bean 的注册。</p><p>这些 Bean 是 Spring 容器的标准组件，确保依赖注入、事件监听等核心功能的正常运行。</p><h2 id="5-1-模拟-ConfigurationClassPostProcessor-ComponentScan-组件扫描"><a href="#5-1-模拟-ConfigurationClassPostProcessor-ComponentScan-组件扫描" class="headerlink" title="5.1 模拟 ConfigurationClassPostProcessor - @ComponentScan 组件扫描"></a>5.1 模拟 ConfigurationClassPostProcessor - @ComponentScan 组件扫描</h2><blockquote><p><em>深入理解 ConfigurationClassPostProcessor，拆解核心的关于组件扫描的逻辑，模拟实现。</em></p></blockquote><p><strong>核心逻辑：</strong>&#x901A;过 ComponentScan 中提供的包路径，找到对应的所有类，检查其中涵盖的类是否有@Component 注解及其派生注解（如@Controller）等，若有则将该类封装为 BeanDefinition，注册入 Spring 容器。</p><p><img src="/images/image-1.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ComponentScan</span> <span class="variable">componentScan</span> <span class="operator">=</span> AnnotationUtils.findAnnotation(Config.class, ComponentScan.class);</span><br><span class="line"><span class="keyword">if</span>(<span class="literal">null</span> != componentScan)&#123;</span><br><span class="line">    <span class="comment">// 遍历ComponentScan注解上的基础包路径</span></span><br><span class="line">    <span class="keyword">for</span> (String basePackage : componentScan.basePackages()) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;basePackage - &quot;</span> + basePackage);</span><br><span class="line">        <span class="comment">// 转为类文件路径</span></span><br><span class="line">        <span class="comment">// com.example.springbootdemo.study.s05_beanfactory_postprocessor.component</span></span><br><span class="line">        <span class="comment">// -&gt; classpath*:com/example/springbootdemo/study/s05_beanfactory_postprocessor/component/**/*.class</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;classpath*:&quot;</span> + basePackage.replace(<span class="string">&quot;.&quot;</span>, <span class="string">&quot;/&quot;</span>) + <span class="string">&quot;/**/*.class&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;path - &quot;</span> + path);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 工厂 - 缓存和读取 Java 类元数据的类，避免重复加载和解析相同的类信息</span></span><br><span class="line">        <span class="type">CachingMetadataReaderFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CachingMetadataReaderFactory</span>();</span><br><span class="line">        <span class="comment">// 工具类 - BeanName生成器</span></span><br><span class="line">        <span class="type">AnnotationBeanNameGenerator</span> <span class="variable">generator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationBeanNameGenerator</span>();</span><br><span class="line">        Resource[] resources = context.getResources(path);</span><br><span class="line">        <span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">            System.out.println(resource);</span><br><span class="line">            <span class="type">MetadataReader</span> <span class="variable">metadataReader</span> <span class="operator">=</span> factory.getMetadataReader(resource);</span><br><span class="line">            System.out.println(<span class="string">&quot;类名: &quot;</span> + metadataReader.getClassMetadata().getClassName());</span><br><span class="line">            <span class="type">AnnotationMetadata</span> <span class="variable">annotationMetadata</span> <span class="operator">=</span> metadataReader.getAnnotationMetadata();</span><br><span class="line">            System.out.println(<span class="string">&quot;是否加了@Component: &quot;</span> + annotationMetadata.hasAnnotation(Component.class.getName()));</span><br><span class="line">            System.out.println(<span class="string">&quot;是否加了@Component派生注解: &quot;</span> + annotationMetadata.hasMetaAnnotation(Component.class.getName()));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 有@Component注解及其派生注解（如@Controller）等，注入Spring容器</span></span><br><span class="line">            <span class="keyword">if</span> (annotationMetadata.hasAnnotation(Component.class.getName())</span><br><span class="line">            || annotationMetadata.hasMetaAnnotation(Component.class.getName())) &#123;</span><br><span class="line">                <span class="type">AbstractBeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> BeanDefinitionBuilder</span><br><span class="line">                        .genericBeanDefinition(metadataReader.getClassMetadata().getClassName())</span><br><span class="line">                        .getBeanDefinition();</span><br><span class="line"></span><br><span class="line">                <span class="type">DefaultListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> context.getDefaultListableBeanFactory();</span><br><span class="line">                <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> generator.generateBeanName(beanDefinition, beanFactory);</span><br><span class="line">                beanFactory.registerBeanDefinition(beanName, beanDefinition);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">basePackage - com.example.springbootdemo.study.s05_beanfactory_postprocessor.component</span><br><span class="line">path - classpath*:com/example/springbootdemo/study/s05_beanfactory_postprocessor/component<span class="comment">/**/</span>*.<span class="keyword">class</span></span><br><span class="line"><span class="title class_">file</span> [D:\JAVA\workSpace\springBootDemo\target\classes\com\example\springbootdemo\study\s05_beanfactory_postprocessor\component\Bean<span class="number">2.</span><span class="keyword">class</span>]</span><br><span class="line">类名: com.example.springbootdemo.study.s05_beanfactory_postprocessor.component.Bean2</span><br><span class="line">是否加了@Component: <span class="literal">true</span></span><br><span class="line">是否加了@Component派生注解: <span class="literal">false</span></span><br><span class="line">file [D:\JAVA\workSpace\springBootDemo\target\classes\com\example\springbootdemo\study\s05_beanfactory_postprocessor\component\Bean<span class="number">3.</span><span class="keyword">class</span>]</span><br><span class="line">类名: com.example.springbootdemo.study.s05_beanfactory_postprocessor.component.Bean3</span><br><span class="line">是否加了@Component: <span class="literal">true</span></span><br><span class="line">是否加了@Component派生注解: <span class="literal">false</span></span><br><span class="line">file [D:\JAVA\workSpace\springBootDemo\target\classes\com\example\springbootdemo\study\s05_beanfactory_postprocessor\component\Bean<span class="number">4.</span><span class="keyword">class</span>]</span><br><span class="line">类名: com.example.springbootdemo.study.s05_beanfactory_postprocessor.component.Bean4</span><br><span class="line">是否加了@Component: <span class="literal">false</span></span><br><span class="line">是否加了@Component派生注解: <span class="literal">false</span></span><br><span class="line"><span class="number">18</span>:<span class="number">51</span>:<span class="number">50.805</span> [main] INFO com.example.springbootdemo.study.s05_beanfactory_postprocessor.component.Bean2 -- Bean2 被Spring管理</span><br><span class="line"><span class="number">18</span>:<span class="number">51</span>:<span class="number">50.808</span> [main] INFO com.example.springbootdemo.study.s05_beanfactory_postprocessor.component.Bean3 -- Bean3 被Spring管理</span><br><span class="line">-----------------------------------</span><br><span class="line">beanName - config</span><br><span class="line">beanName - bean2</span><br><span class="line">beanName - bean3</span><br></pre></td></tr></table></figure><blockquote><p><strong>封装为自定义 BeanFactory 后置处理器</strong></p></blockquote><p>需要<strong>实现 BeanFactoryPostProcessor 接口</strong>，重写其中的 postProcessBeanFactory 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * BeanFactory后置处理器 - 自定义ComponentScan后置处理器</span></span><br><span class="line"><span class="comment"> * func - 扫描Config类上的<span class="doctag">@ComponentScan</span>注解所指定包路径下的所有带有<span class="doctag">@Component</span>注解的Bean并完成注入</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> limoukun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2025/1/2</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ComponentScanPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanFactoryPostProcessor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory configurableListableBeanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ComponentScan</span> <span class="variable">componentScan</span> <span class="operator">=</span> AnnotationUtils.findAnnotation(Config.class, ComponentScan.class);</span><br><span class="line">            <span class="keyword">if</span>(<span class="literal">null</span> != componentScan)&#123;</span><br><span class="line">                <span class="comment">// 遍历ComponentScan注解上的基础包路径</span></span><br><span class="line">                <span class="keyword">for</span> (String basePackage : componentScan.basePackages()) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;basePackage - &quot;</span> + basePackage);</span><br><span class="line">                    <span class="comment">// 转为类文件路径</span></span><br><span class="line">                    <span class="comment">// com.example.springbootdemo.study.s05_beanfactory_postprocessor.component</span></span><br><span class="line">                    <span class="comment">// -&gt; classpath*:com/example/springbootdemo/study/s05_beanfactory_postprocessor/component/**/*.class</span></span><br><span class="line">                    <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;classpath*:&quot;</span> + basePackage.replace(<span class="string">&quot;.&quot;</span>, <span class="string">&quot;/&quot;</span>) + <span class="string">&quot;/**/*.class&quot;</span>;</span><br><span class="line">                    System.out.println(<span class="string">&quot;path - &quot;</span> + path);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 工厂 - 缓存和读取 Java 类元数据的类，避免重复加载和解析相同的类信息</span></span><br><span class="line">                    <span class="type">CachingMetadataReaderFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CachingMetadataReaderFactory</span>();</span><br><span class="line">                    <span class="comment">// 工具类 - BeanName生成器</span></span><br><span class="line">                    <span class="type">AnnotationBeanNameGenerator</span> <span class="variable">generator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationBeanNameGenerator</span>();</span><br><span class="line">                    <span class="comment">// Todo 没理解 context -&gt; new PathMatchingResourcePatternResolver()</span></span><br><span class="line">                    Resource[] resources = <span class="keyword">new</span> <span class="title class_">PathMatchingResourcePatternResolver</span>().getResources(path);</span><br><span class="line">                    <span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">                        System.out.println(resource);</span><br><span class="line">                        <span class="type">MetadataReader</span> <span class="variable">metadataReader</span> <span class="operator">=</span> factory.getMetadataReader(resource);</span><br><span class="line">                        System.out.println(<span class="string">&quot;类名: &quot;</span> + metadataReader.getClassMetadata().getClassName());</span><br><span class="line">                        <span class="type">AnnotationMetadata</span> <span class="variable">annotationMetadata</span> <span class="operator">=</span> metadataReader.getAnnotationMetadata();</span><br><span class="line">                        System.out.println(<span class="string">&quot;是否加了@Component: &quot;</span> + annotationMetadata.hasAnnotation(Component.class.getName()));</span><br><span class="line">                        System.out.println(<span class="string">&quot;是否加了@Component派生注解: &quot;</span> + annotationMetadata.hasMetaAnnotation(Component.class.getName()));</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 有@Component注解及其派生注解（如@Controller）等，注入Spring容器</span></span><br><span class="line">                        <span class="keyword">if</span> (annotationMetadata.hasAnnotation(Component.class.getName())</span><br><span class="line">                                || annotationMetadata.hasMetaAnnotation(Component.class.getName())) &#123;</span><br><span class="line">                            <span class="type">AbstractBeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> BeanDefinitionBuilder</span><br><span class="line">                                    .genericBeanDefinition(metadataReader.getClassMetadata().getClassName())</span><br><span class="line">                                    .getBeanDefinition();</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span>(configurableListableBeanFactory <span class="keyword">instanceof</span> DefaultListableBeanFactory beanFactory)&#123;</span><br><span class="line">                                <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> generator.generateBeanName(beanDefinition, beanFactory);</span><br><span class="line">                                beanFactory.registerBeanDefinition(beanName, beanDefinition);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主调 main 方法中只需要将该后置处理器注入即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">main</span><span class="params">(String[] args)</span> throws IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        GenericApplicationContext context = <span class="keyword">new</span> <span class="built_in">GenericApplicationContext</span>();</span><br><span class="line"></span><br><span class="line">        context.<span class="built_in">registerBean</span>(<span class="string">&quot;config&quot;</span>, Config.<span class="keyword">class</span>);</span><br><span class="line">        <span class="comment">// @ComponentScan @Bean @Import @ImportResource</span></span><br><span class="line"><span class="comment">//        context.registerBean(ConfigurationClassPostProcessor.class);</span></span><br><span class="line">        <span class="comment">// @MapperScanner</span></span><br><span class="line"><span class="comment">//        context.registerBean(MapperScannerConfigurer.class, bd -&gt; &#123;</span></span><br><span class="line"><span class="comment">//            bd.getPropertyValues().add(&quot;basePackage&quot;,</span></span><br><span class="line"><span class="comment">//                    &quot;com.example.springbootdemo.study.s05_beanfactory_postprocessor.mapper&quot;);</span></span><br><span class="line"><span class="comment">//        &#125;);</span></span><br><span class="line">        <span class="comment">// 注入自定义的后置处理器</span></span><br><span class="line">        context.<span class="built_in">registerBean</span>(ComponentScanPostProcessor.<span class="keyword">class</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化容器</span></span><br><span class="line">        context.<span class="built_in">refresh</span>();</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">&quot;-----------------------------------&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String name : context.<span class="built_in">getBeanDefinitionNames</span>()) &#123;</span><br><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">&quot;beanName - &quot;</span> + name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        context.<span class="built_in">close</span>();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="5-2-模拟-ConfigurationClassPostProcessor-Bean-x20"><a href="#5-2-模拟-ConfigurationClassPostProcessor-Bean-x20" class="headerlink" title="5.2 模拟 ConfigurationClassPostProcessor - @Bean&#x20;"></a>5.2 模拟 ConfigurationClassPostProcessor - @Bean&#x20;</h2><blockquote><p><em>深入理解 ConfigurationClassPostProcessor 后置处理器中关于对带有@Bean 注解的类的扫描、解析和注入；</em></p></blockquote><p><strong>核心逻辑</strong>：</p><p>首先来理解所谓的 Bean 工厂以及工厂方法，如果某个 Spring 配置类，其中的方法带有@Bean 注解，代表该方法会用来生产 Bean，那么可以将这个类看作是生产 Bean 的工厂，具体的方法称为工厂方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">xxxConfig</span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Bean1 <span class="title function_">bean1</span><span class="params">()</span>&#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bean1</span>();&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理器会根据类文件目录找寻到 Config.class 二进制文件，解析其中的带有@Bean 注解的方法，对带有参数的施以正确的注入，并将其封装为 BeanDefinition 注入到 Spring 容器中。</p><blockquote><p><em>通过手动解析指定类（<code>Config.class</code>）中的 <code>@Bean</code> 注解方法，动态地将这些方法定义的 Bean 注册到 Spring 容器中；</em></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CachingMetadataReaderFactory</span> <span class="variable">metadataReaderFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CachingMetadataReaderFactory</span>();</span><br><span class="line"><span class="comment">// 从指定的 Resource（Config.class 的字节码文件）中读取元数据。</span></span><br><span class="line"><span class="type">MetadataReader</span> <span class="variable">metadataReader</span> <span class="operator">=</span> metadataReaderFactory.getMetadataReader(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;com/example/springbootdemo/study/s05_beanfactory_postprocessor/Config.class&quot;</span>));</span><br><span class="line">Set&lt;MethodMetadata&gt; methods = metadataReader.getAnnotationMetadata().getAnnotatedMethods(Bean.class.getName());</span><br><span class="line"><span class="keyword">for</span> (MethodMetadata method : methods) &#123;</span><br><span class="line">    System.out.println(method);</span><br><span class="line">    <span class="comment">// 查看当前Bean是否配置了初始化方法</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">initMethod</span> <span class="operator">=</span> method.getAnnotationAttributes(Bean.class.getName()).get(<span class="string">&quot;initMethod&quot;</span>).toString();</span><br><span class="line"></span><br><span class="line">    <span class="type">BeanDefinitionBuilder</span> <span class="variable">beanDefinitionBuilder</span> <span class="operator">=</span> BeanDefinitionBuilder.genericBeanDefinition();</span><br><span class="line">    <span class="comment">// 指定这个 BeanDefinition 的创建逻辑是通过调用 config Bean 上的方法（即 method.getMethodName()）</span></span><br><span class="line">    beanDefinitionBuilder.setFactoryMethodOnBean(method.getMethodName(), <span class="string">&quot;config&quot;</span>);</span><br><span class="line">    beanDefinitionBuilder.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_CONSTRUCTOR);</span><br><span class="line">    <span class="comment">// 将初始化方法设置入BeanDefinition中</span></span><br><span class="line">    <span class="keyword">if</span>(!initMethod.isEmpty())&#123;</span><br><span class="line">        beanDefinitionBuilder.setInitMethodName(initMethod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">AbstractBeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> beanDefinitionBuilder.getBeanDefinition();</span><br><span class="line">    <span class="comment">// 约定@Bean的工厂方法名就是该Bean的beanName</span></span><br><span class="line">    context.getDefaultListableBeanFactory().registerBeanDefinition(method.getMethodName(), beanDefinition);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><em>需要&#x5BF9;<strong>@Bean 的属性</strong>做解析；</em></p><p><em>此处只举例了 initMethod 属性；</em></p></blockquote><p><strong>功能：</strong></p><ul><li>通过手动解析 <code>Config.class</code> 中所有标注了 <code>@Bean</code> 的方法，构建对应的 <code>BeanDefinition</code> 并动态注册到 Spring 容器中。</li></ul><p><strong>核心步骤：</strong></p><ul><li><p>使用 <code>CachingMetadataReaderFactory</code> 读取类的元数据。</p></li><li><p>查找 <code>@Bean</code> 方法并解析其注解属性。</p></li><li><p>构建 <code>BeanDefinition</code> 并注册到容器。</p></li></ul><p><strong>扩展性：</strong></p><ul><li>该代码适合在需要动态加载配置类 Bean 的场景中使用，例如框架扩展、自定义 Bean 注册逻辑等。</li></ul><p><strong>输出结果</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">com.example.springbootdemo.study.s05_beanfactory_postprocessor.Config.<span class="built_in">bean1</span>()</span><br><span class="line">com.example.springbootdemo.study.s05_beanfactory_postprocessor.Config.<span class="built_in">sqlSessionFactoryBean</span>(javax.sql.DataSource)</span><br><span class="line">com.example.springbootdemo.study.s05_beanfactory_postprocessor.Config.<span class="built_in">druidDataSource</span>()</span><br><span class="line"><span class="number">0</span>9:<span class="number">29</span>:<span class="number">44.953</span> [main] INFO com.example.springbootdemo.study.s05_beanfactory_postprocessor.Bean1 -- Bean1 被Spring管理</span><br><span class="line"><span class="number">0</span>9:<span class="number">29</span>:<span class="number">45.052</span> [main] INFO com.alibaba.druid.pool.DruidDataSource -- &#123;dataSource<span class="number">-1</span>&#125; inited</span><br><span class="line">-----------------------------------</span><br><span class="line">beanName - config</span><br><span class="line">beanName - bean1</span><br><span class="line">beanName - sqlSessionFactoryBean</span><br><span class="line">beanName - druidDataSource</span><br><span class="line"><span class="number">0</span>9:<span class="number">29</span>:<span class="number">45.116</span> [main] INFO com.alibaba.druid.pool.DruidDataSource -- &#123;dataSource<span class="number">-1</span>&#125; closing ...</span><br><span class="line"><span class="number">0</span>9:<span class="number">29</span>:<span class="number">45.116</span> [main] INFO com.alibaba.druid.pool.DruidDataSource -- &#123;dataSource<span class="number">-1</span>&#125; closed</span><br></pre></td></tr></table></figure><p>可以看到，@Bean 所标注的方法均生成了对应的 Bean。</p><blockquote><p><strong>封装为自定义 BeanFactory 后置处理器</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * BeanFactory后置处理器 - 自定义<span class="doctag">@Bean</span>后置处理器</span></span><br><span class="line"><span class="comment"> * func - 扫描Config类内的<span class="doctag">@Bean</span>注解下的工厂方法，解析<span class="doctag">@Bean</span>属性，构建BeanDefinition完成注入</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> limoukun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2025/1/3</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanFactoryPostProcessor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory configurableListableBeanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">CachingMetadataReaderFactory</span> <span class="variable">metadataReaderFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CachingMetadataReaderFactory</span>();</span><br><span class="line">            <span class="comment">// 从指定的 Resource（Config.class 的字节码文件）中读取元数据。</span></span><br><span class="line">            <span class="type">MetadataReader</span> <span class="variable">metadataReader</span> <span class="operator">=</span> metadataReaderFactory.getMetadataReader(</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;com/example/springbootdemo/study/s05_beanfactory_postprocessor/Config.class&quot;</span>));</span><br><span class="line">            Set&lt;MethodMetadata&gt; methods = metadataReader.getAnnotationMetadata().getAnnotatedMethods(Bean.class.getName());</span><br><span class="line">            <span class="keyword">for</span> (MethodMetadata method : methods) &#123;</span><br><span class="line">                System.out.println(method);</span><br><span class="line">                <span class="comment">// 查看当前Bean是否配置了初始化方法</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">initMethod</span> <span class="operator">=</span> method.getAnnotationAttributes(Bean.class.getName()).get(<span class="string">&quot;initMethod&quot;</span>).toString();</span><br><span class="line"></span><br><span class="line">                <span class="type">BeanDefinitionBuilder</span> <span class="variable">beanDefinitionBuilder</span> <span class="operator">=</span> BeanDefinitionBuilder.genericBeanDefinition();</span><br><span class="line">                <span class="comment">// 指定这个 BeanDefinition 的创建逻辑是通过调用 config Bean 上的方法（即 method.getMethodName()）</span></span><br><span class="line">                beanDefinitionBuilder.setFactoryMethodOnBean(method.getMethodName(), <span class="string">&quot;config&quot;</span>);</span><br><span class="line">                beanDefinitionBuilder.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_CONSTRUCTOR);</span><br><span class="line">                <span class="comment">// 将初始化方法设置入BeanDefinition中</span></span><br><span class="line">                <span class="keyword">if</span>(!initMethod.isEmpty())&#123;</span><br><span class="line">                    beanDefinitionBuilder.setInitMethodName(initMethod);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">AbstractBeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> beanDefinitionBuilder.getBeanDefinition();</span><br><span class="line">                <span class="comment">// 约定@Bean的工厂方法名就是该Bean的beanName</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (configurableListableBeanFactory <span class="keyword">instanceof</span> DefaultListableBeanFactory beanFactory)&#123;</span><br><span class="line">                    beanFactory.registerBeanDefinition(method.getMethodName(), beanDefinition);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-3-模拟-MapperScannerConfigurer-Mapper"><a href="#5-3-模拟-MapperScannerConfigurer-Mapper" class="headerlink" title="5.3 模拟 MapperScannerConfigurer - @Mapper"></a>5.3 模拟 MapperScannerConfigurer - @Mapper</h2><blockquote><p><em>深入理解<strong>MapperScannerConfigurer</strong>后置处理器中关于对带有@Mapper 注解的类的扫描、解析和注入；</em></p><p><em>该过程即 Spring 与 MyBatis 的整合过程；</em></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * BeanFactory后置处理器 - 自定义<span class="doctag">@Mapper</span>后置处理器</span></span><br><span class="line"><span class="comment"> * func -</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> limoukun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2025/1/3</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapperPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanDefinitionRegistryPostProcessor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry beanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1. 获取指定二进制类文件资源</span></span><br><span class="line">            <span class="type">PathMatchingResourcePatternResolver</span> <span class="variable">resolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PathMatchingResourcePatternResolver</span>();</span><br><span class="line">            Resource[] resources = resolver.getResources(<span class="string">&quot;classpath:com/example/springbootdemo/study/s05_beanfactory_postprocessor/mapper/**/*.class&quot;</span>);</span><br><span class="line">            <span class="type">CachingMetadataReaderFactory</span> <span class="variable">metadataReaderFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CachingMetadataReaderFactory</span>();</span><br><span class="line">            <span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;resource: &quot;</span> + resource);</span><br><span class="line">                <span class="comment">// 2. 逐资源读取元数据</span></span><br><span class="line">                <span class="type">MetadataReader</span> <span class="variable">metadataReader</span> <span class="operator">=</span> metadataReaderFactory.getMetadataReader(resource);</span><br><span class="line">                <span class="comment">// 2.1 判断是否是接口（Mapper接口）</span></span><br><span class="line">                <span class="type">ClassMetadata</span> <span class="variable">classMetadata</span> <span class="operator">=</span> metadataReader.getClassMetadata();</span><br><span class="line">                <span class="keyword">if</span>(classMetadata.isInterface()) &#123;</span><br><span class="line">                    <span class="comment">// 2.2 创建BeanDefinition：构造参数、自动注入方式</span></span><br><span class="line">                    <span class="type">AbstractBeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> BeanDefinitionBuilder.genericBeanDefinition(MapperFactoryBean.class)</span><br><span class="line">                            .setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE)</span><br><span class="line">                            .addConstructorArgValue(Mapper1.class.getName())</span><br><span class="line">                            .getBeanDefinition();</span><br><span class="line">                    System.out.println(<span class="string">&quot;classMetadata.getClassName(): &quot;</span> + classMetadata.getClassName());</span><br><span class="line">                    <span class="comment">// 2.3 构建beanName</span></span><br><span class="line">                    <span class="comment">// 2.4 完成bean注入</span></span><br><span class="line">                    beanFactory.registerBeanDefinition(classMetadata.getClassName(), beanDefinition);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><h3 id="Q：关于-BeanDefinition-注入时-beanName-的考虑？"><a href="#Q：关于-BeanDefinition-注入时-beanName-的考虑？" class="headerlink" title="Q：关于 BeanDefinition 注入时 beanName 的考虑？"></a>Q：关于 BeanDefinition 注入时 beanName 的考虑？</h3><hr><blockquote><p><strong>直接使用 classMetadata.getClassName()</strong></p></blockquote><p><strong>思考</strong>：此处关于 Mapper 的 BeanName 采用了元数据中<code>classMetadata.getClassName()</code>，意味着将使用该 Mapper 的全限定包名作为注入时的 beanName，因此注入 Spring 的结果为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">beanName - com.example.springbootdemo.study.s05_beanfactory_postprocessor.mapper.Mapper1</span><br><span class="line">beanName - com.example.springbootdemo.study.s05_beanfactory_postprocessor.mapper.Mapper2</span><br></pre></td></tr></table></figure><p>我们用 mapper1 或 mapper2 进行查询就会发现 Spring 容器中不存在对应名字的 Bean（但我们的目的便是创建 mapper1、mapper2 两个 Bean）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main中</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">mapper1</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;mapper1&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;尝试获取BeanName为mapper1的Bean - &quot;</span> + mapper1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 控制台输出</span></span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> org.springframework.beans.factory.NoSuchBeanDefinitionException: No bean named <span class="string">&#x27;mapper1&#x27;</span> available</span><br><span class="line">        at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBeanDefinition(DefaultListableBeanFactory.java:<span class="number">893</span>)</span><br><span class="line">        at org.springframework.beans.factory.support.AbstractBeanFactory.getMergedLocalBeanDefinition(AbstractBeanFactory.java:<span class="number">1316</span>)</span><br><span class="line">        at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:<span class="number">299</span>)</span><br><span class="line">        at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:<span class="number">199</span>)</span><br><span class="line">        at org.springframework.context.support.AbstractApplicationContext.getBean(AbstractApplicationContext.java:<span class="number">1158</span>)</span><br><span class="line">        at com.example.springbootdemo.study.s05_beanfactory_postprocessor.Application_04.main(Application_04.java:<span class="number">43</span>)</span><br></pre></td></tr></table></figure><hr><blockquote><p><strong>对 BeanDefinition 用 AnnotationBeanNameGenerator 生成 beanName</strong></p></blockquote><p>聚焦于 for-each 循环中，<strong>关于 BeanDefinition 注入时 beanName 的处理</strong>。</p><p>此处我们构建了 AnnotationBeanNameGenerator 用来根据已创建的 beanDefinition 在 beanFactory 中找到对应的 beanName：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AnnotationBeanNameGenerator</span> <span class="variable">generator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationBeanNameGenerator</span>();</span><br><span class="line"><span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;resource: &quot;</span> + resource);</span><br><span class="line">    <span class="comment">// 2. 逐资源读取元数据</span></span><br><span class="line">    <span class="type">MetadataReader</span> <span class="variable">metadataReader</span> <span class="operator">=</span> metadataReaderFactory.getMetadataReader(resource);</span><br><span class="line">    <span class="comment">// 2.1 判断是否是接口（Mapper接口）</span></span><br><span class="line">    <span class="type">ClassMetadata</span> <span class="variable">classMetadata</span> <span class="operator">=</span> metadataReader.getClassMetadata();</span><br><span class="line">    <span class="keyword">if</span>(classMetadata.isInterface()) &#123;</span><br><span class="line">        <span class="comment">// 2.2 创建BeanDefinition：构造参数、自动注入方式</span></span><br><span class="line">        <span class="type">AbstractBeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> BeanDefinitionBuilder.genericBeanDefinition(MapperFactoryBean.class)</span><br><span class="line">                .setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE)</span><br><span class="line">                .addConstructorArgValue(Mapper1.class.getName())</span><br><span class="line">                .getBeanDefinition();</span><br><span class="line">        System.out.println(<span class="string">&quot;classMetadata.getClassName(): &quot;</span> + classMetadata.getClassName());</span><br><span class="line">        <span class="comment">// 2.3 构建beanName</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> generator.generateBeanName(beanDefinition, beanFactory);</span><br><span class="line">        System.out.println(<span class="string">&quot;构建的beanName: &quot;</span> + beanName);</span><br><span class="line">        <span class="comment">// 2.4 完成bean注入</span></span><br><span class="line">        beanFactory.registerBeanDefinition(beanName, beanDefinition);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">resource: file [D:\JAVA\workSpace\springBootDemo\target\classes\com\example\springbootdemo\study\s05_beanfactory_postprocessor\mapper\Mapper1.class]</span><br><span class="line">classMetadata.getClassName(): com.example.springbootdemo.study.s05_beanfactory_postprocessor.mapper.Mapper1</span><br><span class="line">构建的beanName: mapperFactoryBean</span><br><span class="line">resource: file [D:\JAVA\workSpace\springBootDemo\target\classes\com\example\springbootdemo\study\s05_beanfactory_postprocessor\mapper\Mapper2.class]</span><br><span class="line">classMetadata.getClassName(): com.example.springbootdemo.study.s05_beanfactory_postprocessor.mapper.Mapper2</span><br><span class="line">构建的beanName: mapperFactoryBean</span><br><span class="line"></span><br><span class="line">beanName - mapperFactoryBean</span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> org.springframework.beans.factory.NoSuchBeanDefinitionException: No bean named <span class="string">&#x27;mapper1&#x27;</span> available</span><br><span class="line">        at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBeanDefinition(DefaultListableBeanFactory.java:<span class="number">893</span>)</span><br><span class="line">        at org.springframework.beans.factory.support.AbstractBeanFactory.getMergedLocalBeanDefinition(AbstractBeanFactory.java:<span class="number">1316</span>)</span><br><span class="line">        at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:<span class="number">299</span>)</span><br><span class="line">        at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:<span class="number">199</span>)</span><br><span class="line">        at org.springframework.context.support.AbstractApplicationContext.getBean(AbstractApplicationContext.java:<span class="number">1158</span>)</span><br><span class="line">        at com.example.springbootdemo.study.s05_beanfactory_postprocessor.Application_04.main(Application_04.java:<span class="number">43</span>)</span><br></pre></td></tr></table></figure><p><strong>分析</strong>：由于我们在构建 BeanDefinition 时，传入的类型是<code>MapperFactoryBean.class</code>，导致 mapper1 和 mapper2 先后两次生成的 beanName 都是<code>mapperFactoryBean</code>，而并非是 mapper1&#x2F;mapper2，又由于 Spring 对于重复的 Bean 只会择最后一次注入的为准，因此 Spring 容器中只有一个名为<code>mapperFactoryBean</code>(注意是小写 m 打头)的 Bean。</p><hr><blockquote><p><strong>使用 AnnotationBeanNameGenerator 二次生成 beanName</strong></p></blockquote><p>由于当前生成的 beanName 受限于创建的 BeanDefinition（已绑定为 MapperFactoryBean.class），因此参照 Spring 内部的逻辑，我们再基于当前 Mapper 接口的类信息构建一次 BeanDefinition，并基于此生成出 beanName，就能够解决问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AnnotationBeanNameGenerator</span> <span class="variable">generator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationBeanNameGenerator</span>();</span><br><span class="line"><span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;resource: &quot;</span> + resource);</span><br><span class="line">    <span class="comment">// 2. 逐资源读取元数据</span></span><br><span class="line">    <span class="type">MetadataReader</span> <span class="variable">metadataReader</span> <span class="operator">=</span> metadataReaderFactory.getMetadataReader(resource);</span><br><span class="line">    <span class="comment">// 2.1 判断是否是接口（Mapper接口）</span></span><br><span class="line">    <span class="type">ClassMetadata</span> <span class="variable">classMetadata</span> <span class="operator">=</span> metadataReader.getClassMetadata();</span><br><span class="line">    <span class="keyword">if</span>(classMetadata.isInterface()) &#123;</span><br><span class="line">        <span class="comment">// 2.2 创建BeanDefinition：构造参数、自动注入方式</span></span><br><span class="line">        <span class="type">AbstractBeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> BeanDefinitionBuilder.genericBeanDefinition(MapperFactoryBean.class)</span><br><span class="line">                .setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE)</span><br><span class="line">                .addConstructorArgValue(Mapper1.class.getName())</span><br><span class="line">                .getBeanDefinition();</span><br><span class="line">        System.out.println(<span class="string">&quot;classMetadata.getClassName(): &quot;</span> + classMetadata.getClassName());</span><br><span class="line">        <span class="comment">// 2.3 构建beanName</span></span><br><span class="line">        <span class="comment">// String beanName = generator.generateBeanName(beanDefinition, beanFactory);</span></span><br><span class="line">        <span class="type">AbstractBeanDefinition</span> <span class="variable">beanDefinition1</span> <span class="operator">=</span> BeanDefinitionBuilder</span><br><span class="line">                .genericBeanDefinition(classMetadata.getClassName())</span><br><span class="line">                .getBeanDefinition();</span><br><span class="line">        <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> generator.generateBeanName(beanDefinition1, beanFactory);</span><br><span class="line">        System.out.println(<span class="string">&quot;构建的beanName: &quot;</span> + beanName);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.4 完成bean注入</span></span><br><span class="line">        beanFactory.registerBeanDefinition(beanName, beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">resource: file [D:\JAVA\workSpace\springBootDemo\target\classes\com\example\springbootdemo\study\s05_beanfactory_postprocessor\mapper\Mapper1.class]</span><br><span class="line">classMetadata.getClassName(): com.example.springbootdemo.study.s05_beanfactory_postprocessor.mapper.Mapper1</span><br><span class="line">构建的beanName: mapper1</span><br><span class="line">resource: file [D:\JAVA\workSpace\springBootDemo\target\classes\com\example\springbootdemo\study\s05_beanfactory_postprocessor\mapper\Mapper2.class]</span><br><span class="line">classMetadata.getClassName(): com.example.springbootdemo.study.s05_beanfactory_postprocessor.mapper.Mapper2</span><br><span class="line">构建的beanName: mapper2</span><br><span class="line"></span><br><span class="line">beanName - mapper1</span><br><span class="line">beanName - mapper2</span><br><span class="line">尝试获取BeanName为mapper1的Bean - org.apache.ibatis.binding.MapperProxy@18a136ac</span><br></pre></td></tr></table></figure><blockquote><p><strong>封装为自定义 BeanFactory 后置处理器</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * BeanFactory后置处理器 - 自定义<span class="doctag">@Mapper</span>后置处理器</span></span><br><span class="line"><span class="comment"> * func - 扫描mapper包下的所有带有<span class="doctag">@Mapper</span>的MyBaits定义接口，解析并完成对应Bean的注入</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> limoukun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2025/1/3</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapperPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanDefinitionRegistryPostProcessor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry beanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1. 获取指定二进制类文件资源</span></span><br><span class="line">            <span class="type">PathMatchingResourcePatternResolver</span> <span class="variable">resolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PathMatchingResourcePatternResolver</span>();</span><br><span class="line">            Resource[] resources = resolver.getResources(<span class="string">&quot;classpath:com/example/springbootdemo/study/s05_beanfactory_postprocessor/mapper/**/*.class&quot;</span>);</span><br><span class="line">            <span class="type">CachingMetadataReaderFactory</span> <span class="variable">metadataReaderFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CachingMetadataReaderFactory</span>();</span><br><span class="line">            <span class="type">AnnotationBeanNameGenerator</span> <span class="variable">generator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationBeanNameGenerator</span>();</span><br><span class="line">            <span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;resource: &quot;</span> + resource);</span><br><span class="line">                <span class="comment">// 2. 逐资源读取元数据</span></span><br><span class="line">                <span class="type">MetadataReader</span> <span class="variable">metadataReader</span> <span class="operator">=</span> metadataReaderFactory.getMetadataReader(resource);</span><br><span class="line">                <span class="comment">// 2.1 判断是否是接口（Mapper接口）</span></span><br><span class="line">                <span class="type">ClassMetadata</span> <span class="variable">classMetadata</span> <span class="operator">=</span> metadataReader.getClassMetadata();</span><br><span class="line">                <span class="keyword">if</span>(classMetadata.isInterface()) &#123;</span><br><span class="line">                    <span class="comment">// 2.2 创建BeanDefinition：构造参数、自动注入方式</span></span><br><span class="line">                    <span class="type">AbstractBeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> BeanDefinitionBuilder.genericBeanDefinition(MapperFactoryBean.class)</span><br><span class="line">                            .setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE)</span><br><span class="line">                            .addConstructorArgValue(Mapper1.class.getName())</span><br><span class="line">                            .getBeanDefinition();</span><br><span class="line">                    System.out.println(<span class="string">&quot;classMetadata.getClassName(): &quot;</span> + classMetadata.getClassName());</span><br><span class="line">                    <span class="comment">// 2.3 构建beanName</span></span><br><span class="line"><span class="comment">//                    String beanName = generator.generateBeanName(beanDefinition, beanFactory);</span></span><br><span class="line">                    <span class="type">AbstractBeanDefinition</span> <span class="variable">beanDefinition1</span> <span class="operator">=</span> BeanDefinitionBuilder</span><br><span class="line">                            .genericBeanDefinition(classMetadata.getClassName())</span><br><span class="line">                            .getBeanDefinition();</span><br><span class="line">                    <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> generator.generateBeanName(beanDefinition1, beanFactory);</span><br><span class="line">                    System.out.println(<span class="string">&quot;构建的beanName: &quot;</span> + beanName);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 2.4 完成bean注入</span></span><br><span class="line">                    beanFactory.registerBeanDefinition(beanName, beanDefinition);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><h1 id="六、Aware-与-InitializingBean-接口"><a href="#六、Aware-与-InitializingBean-接口" class="headerlink" title="六、Aware 与 InitializingBean 接口"></a>六、Aware 与 InitializingBean 接口</h1><p><img src="/images/image-4.png"></p><p><strong>网友理解</strong>：</p><ul><li><p>个别情况不能用注解注入，只能用实现 aware 接口的类进行手动注入，应用开发了解即可；</p></li><li><p>当你需要使用容器的时候，那个发布事件的功能，需要用到 context 容器，你要使用 Aware 这样的机制获取 context，当然，你使用 autowired 也可以；</p></li></ul><p><img src="/images/image-3.png"></p><h2 id="6-1-BeanNameAware、ApplicationContextAware"><a href="#6-1-BeanNameAware、ApplicationContextAware" class="headerlink" title="6.1 BeanNameAware、ApplicationContextAware"></a>6.1 BeanNameAware、ApplicationContextAware</h2><blockquote><p><strong>BeanNameAware - 感知 BeanName 的能力</strong></p></blockquote><p>在 Spring 中，实现了 <code>BeanNameAware</code> 接口的类可以感知到它在 Spring 容器中所对应的 <strong>bean 的名字</strong>。这个接口的主要作用是：</p><ol><li><p><strong>注入 bean 的名字</strong>：让 bean 知道它在容器中的名字；</p></li><li><p><strong>实现自定义逻辑</strong>：在获取到 beanName 后，实现一些与其名字相关的自定义逻辑；</p></li></ol><blockquote><p><em><code>BeanNameAware</code> 的核心目标是 <strong>让 bean 知道自己的名字</strong>，而非让外界知道其名字或为其设置名字；</em></p></blockquote><p><strong>&gt;&gt; BeanNameAware 接口：是 Spring 的内置接口（非拓展接口）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanNameAware</span> <span class="keyword">extends</span> <span class="title class_">Aware</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Set the name of the bean in the bean factory that created this bean.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Invoked after population of normal bean properties but before an</span></span><br><span class="line"><span class="comment">     * init callback such as &#123;<span class="doctag">@link</span> InitializingBean#afterPropertiesSet()&#125;</span></span><br><span class="line"><span class="comment">     * or a custom init-method.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name the name of the bean in the factory.</span></span><br><span class="line"><span class="comment">     * Note that this name is the actual bean name used in the factory, which may</span></span><br><span class="line"><span class="comment">     * differ from the originally specified name: in particular for inner bean</span></span><br><span class="line"><span class="comment">     * names, the actual bean name might have been made unique through appending</span></span><br><span class="line"><span class="comment">     * &quot;#...&quot; suffixes. Use the &#123;<span class="doctag">@link</span> BeanFactoryUtils#originalBeanName(String)&#125;</span></span><br><span class="line"><span class="comment">     * method to extract the original bean name (without suffix), if desired.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setBeanName</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当一个 Bean 实现该接口后，Spring 容器会在完成 Bean 的实例化和属性填充后、初始化回调方法（如 <code>@PostConstruct</code> 或 <code>InitializingBean#afterPropertiesSet</code>）之前调用<code>setBeanName(String name)</code>方法，把该 bean 在容器中的名字注入进去。</p><p><strong>&gt;&gt; 使用场景：</strong></p><ul><li><p>日志记录：在调试或日志中记录 bean 的名字，方便排查问题。</p></li><li><p>动态行为：根据 bean 名字调整行为，例如为不同名字的 bean 加载不同的配置。</p></li><li><p>框架开发：在开发自定义框架时，通过感知 bean 名字实现对容器中 bean 的管理</p></li></ul><blockquote><p><strong>ApplicationContextAware - 感知与访问 Spring 容器的能力</strong></p></blockquote><p>实现该接口的类能够访问到 Spring 容器（即 <code>ApplicationContext</code>）本身，从而让 bean 知道它是在哪个应用上下文中运行的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ApplicationContextAware</span> <span class="keyword">extends</span> <span class="title class_">Aware</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Set the ApplicationContext that this object runs in.</span></span><br><span class="line"><span class="comment">     * Normally this call will be used to initialize the object.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Invoked after population of normal bean properties but before an init callback such</span></span><br><span class="line"><span class="comment">     * as &#123;<span class="doctag">@link</span> org.springframework.beans.factory.InitializingBean#afterPropertiesSet()&#125;</span></span><br><span class="line"><span class="comment">     * or a custom init-method. Invoked after &#123;<span class="doctag">@link</span> ResourceLoaderAware#setResourceLoader&#125;,</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> ApplicationEventPublisherAware#setApplicationEventPublisher&#125; and</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> MessageSourceAware&#125;, if applicable.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> applicationContext the ApplicationContext object to be used by this object</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ApplicationContextException in case of context initialization errors</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> BeansException if thrown by application context methods</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> org.springframework.beans.factory.BeanInitializationException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现 <code>ApplicationContextAware</code> 接口的类可以在 Spring 容器创建并初始化 bean 后，获取到 <code>ApplicationContext</code> 实例，从而访问到 Spring 容器中的其他组件、配置或者 bean。</p><blockquote><p><strong>*用途</strong>：获取协作 Bean、资源访问、事件发布（需要传入 Context）、消息源访问；*</p></blockquote><blockquote><p><strong>测试</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;myBean&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBean</span> <span class="keyword">implements</span> <span class="title class_">BeanNameAware</span>, ApplicationContextAware, InitializingBean &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现BeanNameAware - 注入Bean的名字</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBeanName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;bean - &#123;&#125;, beanName - &#123;&#125;&quot;</span>, <span class="built_in">this</span>, name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现ApplicationContextAware - 注入Spring容器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> applicationContext Spring容器</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        log.info(<span class="string">&quot;bean - &#123;&#125;, applicationContext - &#123;&#125;&quot;</span>, <span class="built_in">this</span>, applicationContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现InitializingBean - 初始化前添加自定义逻辑</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        log.info(<span class="string">&quot;bean - &#123;&#125; 初始化&quot;</span>, <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line"></span><br><span class="line">    context.registerBean(<span class="string">&quot;myBean&quot;</span>, MyBean.class);</span><br><span class="line"></span><br><span class="line">    context.refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">17</span>:<span class="number">15</span>:<span class="number">12.277</span> [main] INFO myBean -- bean - com.example.springbootdemo.study.s06_aware_initializingBean.MyBean@3578436e, beanName - myBean</span><br><span class="line"><span class="number">17</span>:<span class="number">15</span>:<span class="number">12.283</span> [main] INFO myBean -- bean - com.example.springbootdemo.study.s06_aware_initializingBean.MyBean@3578436e, applicationContext - org.springframework.context.support.GenericApplicationContext@64616ca2, started on Tue Jan <span class="number">07</span> <span class="number">17</span>:<span class="number">15</span>:<span class="number">12</span> GMT+08:<span class="number">00</span> <span class="number">2025</span></span><br><span class="line"><span class="number">17</span>:<span class="number">15</span>:<span class="number">12.300</span> [main] INFO myBean -- bean - com.example.springbootdemo.study.s06_aware_initializingBean.MyBean@3578436e 初始化</span><br></pre></td></tr></table></figure><h3 id="Q：-Autowired-能够平替-ApplicationContextAware-接口功能，为什么还使用-Aware-接口呢？"><a href="#Q：-Autowired-能够平替-ApplicationContextAware-接口功能，为什么还使用-Aware-接口呢？" class="headerlink" title="Q：@Autowired 能够平替 ApplicationContextAware 接口功能，为什么还使用 Aware 接口呢？"></a>Q：@Autowired 能够平替 ApplicationContextAware 接口功能，为什么还使用 Aware 接口呢？</h3><hr><p>对<code>@Autowired</code>的解析需要用到 Bean 的后置处理器，属于是 Spring 的扩展功能；</p><p>而 Aware 接口属于内置功能，不加任何扩展的情况下 Spring 就能够识别出；</p><blockquote><p><strong>@Autowired 失效情况与分析</strong></p></blockquote><p>先看如下例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//        context.registerBean(&quot;myBean&quot;, MyBean.class);</span></span><br><span class="line">    context.registerBean(<span class="string">&quot;config1&quot;</span>,Config1.class);</span><br><span class="line">    context.registerBean(AutowiredAnnotationBeanPostProcessor.class);</span><br><span class="line">    context.registerBean(CommonAnnotationBeanPostProcessor.class);</span><br><span class="line">    context.registerBean(ConfigurationClassPostProcessor.class);</span><br><span class="line"></span><br><span class="line">    context.refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Config1.java</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;Config1&quot;)</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Config1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;注入 ApplicationContext&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">17</span>:<span class="number">38</span>:<span class="number">29.848</span> [main] INFO Config1 -- 注入 ApplicationContext</span><br><span class="line"><span class="number">17</span>:<span class="number">38</span>:<span class="number">29.850</span> [main] INFO Config1 -- 初始化</span><br></pre></td></tr></table></figure><p><code>@Autowired</code>注解和<code>@PostConstruct</code>注解能够正常被解析，说明对应的后置处理器都能够正常注入 Spring 容器；</p><hr><p>将 Config1 修改如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;Config1&quot;)</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Config1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;注入 ApplicationContext&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> BeanFactoryPostProcessor <span class="title function_">processor</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beanFactory -&gt; &#123;</span><br><span class="line">            log.info(<span class="string">&quot;执行processor&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">context.registerBean(<span class="string">&quot;config1&quot;</span>,Config1.class);</span><br><span class="line"><span class="comment">//        context.registerBean(&quot;config2&quot;,Config2.class);</span></span><br><span class="line">context.registerBean(AutowiredAnnotationBeanPostProcessor.class);</span><br><span class="line">context.registerBean(CommonAnnotationBeanPostProcessor.class);</span><br><span class="line">context.registerBean(ConfigurationClassPostProcessor.class);</span><br><span class="line"></span><br><span class="line">context.refresh();</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span>:<span class="number">42</span>:<span class="number">14.208</span> [main] INFO org.springframework.context.annotation.ConfigurationClassEnhancer -- <span class="meta">@Bean</span> method Config1.processor is non-<span class="keyword">static</span> and returns an object assignable to Spring<span class="string">&#x27;s BeanFactoryPostProcessor interface. This will result in a failure to process annotations such as @Autowired, @Resource and @PostConstruct within the method&#x27;</span>s declaring <span class="meta">@Configuration</span> class. Add the <span class="string">&#x27;static&#x27;</span> modifier to <span class="built_in">this</span> method to avoid these container lifecycle issues; see <span class="meta">@Bean</span> javadoc <span class="keyword">for</span> complete details.</span><br><span class="line"><span class="number">10</span>:<span class="number">42</span>:<span class="number">14.210</span> [main] INFO Config1 -- 执行processor</span><br></pre></td></tr></table></figure><p><strong>分析</strong>：<code>@Autowired</code>注解和<code>@PostConstruct</code>注解不能被正确解析，BeanFactoryProcessor 被注入 Spring；</p><p>正常的 Spring 生命周期如下（配置类中不含 BeanFactoryPostProcessor 注入）：</p><p><img src="https://raw.githubusercontent.com/Tomorrowllbefine/Study/master/pics/image-16.png" alt="图 正常的Spring生命周期"></p><p>顺序依次是：BeanFactoryPostProcessor（Bean 工厂后置处理器）、BeanPostProcessor（Bean 生命周期后置处理器）、完成 Bean 的实例化和初始化；</p><p>而当前情形是<strong>配置类中包含了<code>BeanFactoryPostProcessor</code><strong>，使得要创建其中的<code>BeanFactoryPostProcessor</code>必须</strong>提前创建和初始化</strong>出 Java 配置类，但这时候的配置类还未准备好其它的扩展<code>BeanPostProcessor</code>，就要开始执行<code>BeanFactoryPostProcessor</code>，导致没有对应的 Bean 后置处理器解析<code>@Autowired</code>注解。</p><blockquote><p><em>初始化过程中，Spring 内置的方法如 Aware 接口以及 InitializingBean 接口的回调方法会被执行；</em></p></blockquote><p><img src="https://raw.githubusercontent.com/Tomorrowllbefine/Study/master/pics/image-17.png" alt="图 配置类中含有BeanFactoryPostProcessor注入的生命周期"></p><hr><blockquote><p><strong>解决方案</strong></p></blockquote><ol><li><p>用内置依赖注入和初始化取代扩展依赖注入和初始化；</p></li><li><p>用静态工厂方法代替实例工厂方法，避免工厂对象提前被创建；</p></li></ol><p>此处我们探讨方案一。</p><p>在 Config2 配置类中，采用实现内置依赖注入和初始化接口的方式实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;Config1&quot;)</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Config2</span> <span class="keyword">implements</span> <span class="title class_">ApplicationContextAware</span>, InitializingBean &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        log.info(<span class="string">&quot;初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        log.info(<span class="string">&quot;注入 ApplicationContext&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> BeanFactoryPostProcessor <span class="title function_">processor</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beanFactory -&gt; &#123;</span><br><span class="line">            log.info(<span class="string">&quot;执行processor&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11</span>:<span class="number">19</span>:<span class="number">33.141</span> [main] INFO Config1 -- 注入 ApplicationContext</span><br><span class="line"><span class="number">11</span>:<span class="number">19</span>:<span class="number">33.143</span> [main] INFO Config1 -- 初始化</span><br><span class="line"><span class="number">11</span>:<span class="number">19</span>:<span class="number">33.145</span> [main] INFO org.springframework.context.annotation.ConfigurationClassEnhancer -- <span class="meta">@Bean</span> method Config2.processor is non-<span class="keyword">static</span> and returns an object assignable to Spring<span class="string">&#x27;s BeanFactoryPostProcessor interface. This will result in a failure to process annotations such as @Autowired, @Resource and @PostConstruct within the method&#x27;</span>s declaring <span class="meta">@Configuration</span> class. Add the <span class="string">&#x27;static&#x27;</span> modifier to <span class="built_in">this</span> method to avoid these container lifecycle issues; see <span class="meta">@Bean</span> javadoc <span class="keyword">for</span> complete details.</span><br><span class="line"><span class="number">11</span>:<span class="number">19</span>:<span class="number">33.146</span> [main] INFO Config1 -- 执行processor</span><br></pre></td></tr></table></figure><blockquote><p><strong>总结</strong></p></blockquote><ol><li><p>Aware 接口、提供【内置】的注入手段；</p></li><li><p>InitializingBean 接口提供了一种【内置】的初始化手段；</p></li><li><p>内置的注入和初始化不受扩展功能的影响，总会被执行，因此在 Spring 框架内部经常会被使用；</p></li></ol><h3 id="Q：关于为什么-Bean-会被解析？"><a href="#Q：关于为什么-Bean-会被解析？" class="headerlink" title="Q：关于为什么@Bean 会被解析？"></a>Q：关于为什么@Bean 会被解析？</h3><hr><p>在 Spring 容器的启动过程中，<code>ConfigurationClassPostProcessor</code> 作为一个特殊的 <code>BeanFactoryPostProcessor</code>，会在 <code>BeanFactoryPostProcessor</code> 被调用的阶段被调用。</p><p>自定义的 <code>BeanFactoryPostProcessor</code> 会在 <code>ConfigurationClassPostProcessor</code> 之后执行，因为 Spring 首先需要 <code>ConfigurationClassPostProcessor</code> 来解析配置类，生成正确的 Bean 定义。</p><p>内置和自定义 <code>BeanFactoryPostProcessor</code> 的执行顺序：</p><ul><li><p>Spring 会将 <code>BeanFactoryPostProcessor</code> 分为不同的类别：</p><ul><li><p>实现 <code>PriorityOrdered</code> 的 <code>BeanFactoryPostProcessor</code> 会先执行。</p></li><li><p>实现 <code>Ordered</code> 的 <code>BeanFactoryPostProcessor</code> 会接着执行。</p></li><li><p>普通的 <code>BeanFactoryPostProcessor</code> 最后执行。</p></li></ul></li><li><p><code>ConfigurationClassPostProcessor</code> 通常属于实现 <code>PriorityOrdered</code> 的处理器，会较早执行。</p></li><li><p>自定义的 <code>customBeanFactoryPostProcessor</code> 通常是普通的 <code>BeanFactoryPostProcessor</code>，会在 <code>ConfigurationClassPostProcessor</code> 等 <code>PriorityOrdered</code> 或 <code>Ordered</code> 的处理器之后执行。</p></li></ul><h1 id="七、Spring-Bean-的初始化和销毁"><a href="#七、Spring-Bean-的初始化和销毁" class="headerlink" title="七、Spring Bean 的初始化和销毁"></a>七、Spring Bean 的初始化和销毁</h1><p>Spring 提供了多种初始化手段，除了 @PostConstruct，@Bean(initMethod) 之外，还可以实现 InitializingBean 接口来进行初始化，如果同一个 bean 用了以上手段声明了 3 个初始化方法，那么它们的执行顺序是：</p><ol><li><p>@PostConstruct 标注的初始化方法；</p></li><li><p>InitializingBean 接口的初始化方法；</p></li><li><p>@Bean(initMethod) 指定的初始化方法；</p></li></ol><p>与初始化类似，Spring 也提供了多种<strong>销毁</strong>手段，执行顺序为：</p><ol><li><p>@PreDestroy 标注的销毁方法</p></li><li><p>DisposableBean 接口的销毁方法</p></li><li><p>@Bean(destroyMethod) 指定的销毁方法</p></li></ol><h1 id="八、Scope"><a href="#八、Scope" class="headerlink" title="八、Scope"></a>八、Scope</h1><p><img src="https://raw.githubusercontent.com/Tomorrowllbefine/Study/master/pics/image-15.png"></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;BeanFactory&quot;&gt;&lt;a href=&quot;#BeanFactory&quot; class=&quot;headerlink&quot; title=&quot;BeanFactory&quot;&gt;&lt;/a&gt;BeanFactory&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;BeanFactory 实现类：&lt;/strong&gt;&amp;#x63D0;供 IOC、DI、Bean 生命周期各种功能实现&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// DefaultSingletonBeanRegistry.java&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;DefaultSingletonBeanRegistry&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;SimpleAliasRegistry&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;SingletonBeanRegistry&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; Map&amp;lt;String, Object&amp;gt; singletonObjects = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;ConcurrentHashMap&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;256&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title function_&quot;&gt;DefaultSingletonBeanRegistry&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;div style=&quot;text-align: center;&quot;&gt;
    &lt;img src=&quot;https://raw.githubusercontent.com/Tomorrowllbefine/Study/master/pics/image-14.png&quot; width=&quot;80%&quot; height=&quot;80%&quot;&gt;
&lt;/div&gt;

&lt;br&gt;</summary>
    
    
    
    
    <category term="backend" scheme="https://tomorrowllbefine.github.io/tags/backend/"/>
    
  </entry>
  
  <entry>
    <title>技术阅读 | 软件架构课</title>
    <link href="https://tomorrowllbefine.github.io/2024/12/22/%E3%80%8A%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AF%BE%E3%80%8B/"/>
    <id>https://tomorrowllbefine.github.io/2024/12/22/%E3%80%8A%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AF%BE%E3%80%8B/</id>
    <published>2024-12-22T06:38:25.000Z</published>
    <updated>2024-12-22T06:41:51.105Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、演进中的架构"><a href="#一、演进中的架构" class="headerlink" title="一、演进中的架构"></a>一、演进中的架构</h1><h2 id="01-原始分布式时代：Unix设计哲学下的服务探索"><a href="#01-原始分布式时代：Unix设计哲学下的服务探索" class="headerlink" title="01 | 原始分布式时代：Unix设计哲学下的服务探索"></a>01 | 原始分布式时代：Unix设计哲学下的服务探索</h2><p><img src="https://raw.githubusercontent.com/Tomorrowllbefine/Study/master/pics/image-6.png"></p><p>就我个人而言，我对”微服务中的简单”的理解，是指微服务中的每个服务，每一个中间件，服务中的每个接口，都是”简单”的，同时也应该以”简单“作为目标进行设计。</p><p>正如很多前辈所言，微服务的出现，目的为了弥补单应用中存在的各个缺陷，如业务功能过多导致代码的耦合度很大，某个功能使用频繁高，占用资源多（本身这个功能可能跟业务无关，但是因为占用大量资源导致整个系统不可用）等等。</p><span id="more"></span><p>这个时候，我们可能会基于业务功能，对应用进行拆分，把每个业务拆分出来，做成一个微服务应用。功能模块的拆分有几个好处，一是在开发团队人员充足的情况下，每个人需要维护的代码变简单了，二是整个系统解耦了，每个服务也可以互相调用，换句话说就是系统的复用性变高了，三是，在单个微服务变得不可用的情况下，如果配置的好，是不会影响整个系统正常运行，从一定程度上提高了系统的可靠性和可用性。</p><p>基于这个思路，我想中台和serveless的诞生，也是基于这些准则，比如在后期发现，随着业务不停扩展，代码中有好多功能是通用的，那么是不是可以把这些这些代码抽出来，做成一个个模块，给各个应用级的微服务应用进行调用呢？（基础平台的职责）</p><p>当然，也正如老师所说的，就从整个架构来说，其实微服务并不是这么简单的，既然拆分了应用，那么不可避免的，你就会遇到这些问题：</p><ol><li><p>各个微服务之间怎么知道接口的地址在哪（服务发现和服务注册中间件）</p></li><li><p>服务之间该用什么协议进行通讯和接口的调用（rpc调用中间件）</p></li><li><p>某个服务突然不可用了，我又不能影响整个系统的可用性，我该怎么办（服务降级，熔断）</p></li><li><p>为了提高某个服务可用性，我做了集群（同样的服务，在不同的节点开了应用），我该怎么分配落在这个集群中的请求（负载均衡中间件）</p></li><li><p>外部怎么能够访问这个系统中的某个微服务（网关中间件）等等（如分布式系统中的锁设计和事务实现）</p></li></ol><p>总而来说，“微服务的简单”，这个命题还挺有意思的，它就像一个有多个pics的乐高模型一样，对于每个pic的积木而言，确实很简单，但是就整体而言，它是由多块积木拼起来的，往往就比较，复杂，也需要我们去花心思去思考，去完成。</p><p>我觉得”简单”二字，不仅仅一门艺术，同时也很考验我们程序员的技术和设计能力。我想这也是大部分程序员的目标和初衷吧。</p><h2 id="03-SOA时代：成功理论与失败实践"><a href="#03-SOA时代：成功理论与失败实践" class="headerlink" title="03 | SOA时代：成功理论与失败实践"></a>03 | SOA时代：成功理论与失败实践</h2><p><img src="https://raw.githubusercontent.com/Tomorrowllbefine/Study/master/pics/image-9.png"></p><p><strong>网友</strong>：</p><p><img src="https://raw.githubusercontent.com/Tomorrowllbefine/Study/master/pics/image-10.png"></p><p><img src="https://raw.githubusercontent.com/Tomorrowllbefine/Study/master/pics/image-8.png"></p><h2 id="04-微服务时代：SOA的革命者"><a href="#04-微服务时代：SOA的革命者" class="headerlink" title="04 | 微服务时代：SOA的革命者"></a>04 | 微服务时代：SOA的革命者</h2><p>服务的注册发现、跟踪治理、负载均衡、故障隔离、认证授权、伸缩扩展、传输通讯、事务处理等问题，在微服务中，都不再会有统一的解决方案。</p><h2 id="05-后微服务时代：跨越软件与硬件之间的界限"><a href="#05-后微服务时代：跨越软件与硬件之间的界限" class="headerlink" title="05 | 后微服务时代：跨越软件与硬件之间的界限"></a>05 | 后微服务时代：跨越软件与硬件之间的界限</h2><hr><p>在微服务架构中，会面临一些必须要解决的问题，如注册发现、跟踪治理、复杂均衡、传输通讯等。</p><p>但这些问题，实际上在SOA时代甚至可以说自原始分布式时代，就一直存在了。既然只要是分布式系统，就没办法完全避免这些问题，那反过来思考：<strong>这些问题需要分布式系统自己来解决吗？</strong></p><p><strong>Q：分布式架构发展到服务网格后，真的是到达“最好的时代”了吗？软件架构的发展不太可能真的就此止步，你认为今天的云原生还有哪些主要矛盾，下一次软件架构的进化将会主要解决什么问题？</strong></p><p><img src="https://raw.githubusercontent.com/Tomorrowllbefine/Study/master/pics/image.png"></p><h2 id="06-无服务时代：“不分布式”云端系统的起点"><a href="#06-无服务时代：“不分布式”云端系统的起点" class="headerlink" title="06 | 无服务时代：“不分布式”云端系统的起点"></a>06 | 无服务时代：“不分布式”云端系统的起点</h2><hr><p><strong>Q：你是否了解、接触过无服务架构？无服务目前在中国处于起步的发展阶段，阿里云、腾讯云的无服务计算框架，都给了普通用户相当大的免费额度，你愿意去试一下吗？</strong></p><p><img src="https://raw.githubusercontent.com/Tomorrowllbefine/Study/master/pics/image-4.png"></p><p><img src="https://raw.githubusercontent.com/Tomorrowllbefine/Study/master/pics/image-2.png"></p><h1 id="二、架构师的视角"><a href="#二、架构师的视角" class="headerlink" title="二、架构师的视角"></a>二、架构师的视角</h1><h2 id="07-远程服务调用（上）：从本地方法到远程方法的桥梁"><a href="#07-远程服务调用（上）：从本地方法到远程方法的桥梁" class="headerlink" title="07 | 远程服务调用（上）：从本地方法到远程方法的桥梁"></a>07 | 远程服务调用（上）：从本地方法到远程方法的桥梁</h2><hr><p><strong>RPC</strong> 出现的最初目的，就是为了<strong>让计算机能够跟调用本地方法一样，去调用远程方法</strong>。</p><h3 id="1）进程间通讯"><a href="#1）进程间通讯" class="headerlink" title="1）进程间通讯"></a>1）进程间通讯</h3><p>先了解一下在本地方法调用时，发生了什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用者（Caller）      ： main()</span></span><br><span class="line"><span class="comment">// 被调用者（Callee）      ： println()</span></span><br><span class="line"><span class="comment">// 调用点（Call Site）   ： 发生方法调用的指令流位置</span></span><br><span class="line"><span class="comment">// 调用参数（Parameter） ： 由Caller传递给Callee的数据，即“hello world”</span></span><br><span class="line"><span class="comment">// 返回值（Retval）      ： 由Callee传递给Caller的数据，如果方法正常完成，返回值是void，否则是对应的异常</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  System.out.println(“hello world”);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在不考虑编译器优化的前提下，程序运行至调用 <code>println()</code> 这一行时，计算机（物理机或虚拟机）会做以下事情：</p><ul><li><p><strong>传递方法参数</strong>：将字符串”hello world”的引用压栈；</p></li><li><p><strong>确定方法版本</strong>：根据<code>println()</code>方法的签名，确定它的执行版本其实并不是一个简单的过程，不管是编译时的静态解析也好，还是运行时的动态分配也好，程序都必须通过某些语言规范中明确定义的原则，找到明确的被调用者Callee。</p></li></ul><blockquote><p>此处的明确指唯一一个Callee，或者有严格优先级的多个Callee，如不同的重载版本；</p></blockquote><ul><li><p><strong>执行被调方法</strong>：从栈中获得Parameter，以此为输入，执行Callee内部的逻辑；</p></li><li><p><strong>执行返回结果</strong>：将Callee的执行结果压栈，并将指令流恢复到Call Site处，据悉向下执行；</p></li></ul><p>接下来，我们就需要考虑一下，<strong>当 println() 方法不在当前进程的内存地址空间中</strong>，会出现什么问题。</p><p>不难想到，此时至少面临<strong>两个直接的障碍</strong>：</p><ul><li><p>第一个障碍：前面的<strong>第一步</strong>和<strong>第四步</strong>所做的<strong>传递参数、传回结果都依赖于栈内存的帮助</strong>，如果 Caller 与 Callee 分属不同的进程，就不会拥有相同的栈内存，那么在 Caller 进程的内存中将参数压栈，对于 Callee 进程的执行毫无意义；</p></li><li><p>第二个障碍：<strong>第二步的方法版本选择依赖于语言规则的定义</strong>，而如果 Caller 与 Callee 不是同一种语言实现的程序，方法版本选择就将是一项模糊的不可知行为；</p></li></ul><blockquote><p><em>为了简化，暂时忽略第二个障碍，假设 Caller 与 Callee 是使用同一种语言实现的；</em></p></blockquote><p>解决两个进程之间如何交换数据的问题，这件事情在计算机科学中被称为“<strong>进程间通讯</strong>”（Inter-Process Communication，IPC）。</p><blockquote><p><strong>管道&#x2F;具名管道</strong></p></blockquote><p>管道其实类似于两个进程间的桥梁，用于进程间传递少量的字符流或字节流。<strong>普通管道</strong>可用于<strong>有亲缘关系进程间的通信</strong>（由一个进程启动的另外一个进程）；而<strong>具名管道</strong>摆脱了普通管道没有名字的限制，除了具有普通管道所具有的功能以外，它还<strong>允许无亲缘关系进程间的通信</strong>。</p><blockquote><p><em>管道典型的应用就是命令行中的“ | ”操作符，比如说，命令“ps -ef | grep java”  ，就是管道操作符“ | ”将 ps 命令的标准输出通过管道，连接到 grep 命令的标准输入上。</em></p></blockquote><blockquote><p><strong>信号（Signal）</strong></p></blockquote><p><strong>信号是用来通知目标进程有某种事件发生的</strong>。除了用于进程间通信外，信号还可以被进程发送给进程自身。信号的典型应用是 kill 命令，比如“kill -9 pid”，意思就是由 Shell 进程向指定 PID 的进程发送 SIGKILL 信号。</p><blockquote><p><strong>信号量（Semaphore）</strong></p></blockquote><p>信号量是用于两个进程之间同步协作的手段，相当于操作系统提供的一个特殊变量。我们可以在信号量上，进行 <code>wait()</code> 和 <code>notify()</code> 操作。</p><blockquote><p><strong>消息队列</strong></p></blockquote><p>前面所说的这三种方式，只适合传递少量信息，而 POSIX 标准中，有定义“消息队列”用于进程间通讯的方法。也就是说，进程可以向队列中添加消息，而被赋予读权限的进程则可以从队列中消费消息。消息队列就克服了信号承载信息量少、管道只能用于无格式字节流，以及缓冲区大小受限等缺点  ，但实时性相对受限。</p><blockquote><p><strong>共享内存</strong></p></blockquote><p>允许多个进程可以访问同一块内存空间，这是<strong>效率最高</strong>的进程间通讯形式。虽然进程的内存地址空间是独立隔离的，但<strong>OS提供了让进程主动创建、映射、分离、控制某一块内存的接口</strong>。由于内存是多进程共享的，所以往往会与其它通信机制如信号量等结合使用，来达到进程间的同步及互斥；</p><blockquote><p><strong>本地套接字接口（IPC Socket）</strong></p></blockquote><p>消息队列和共享内存这两种方式，只适合单机多进程间的通讯。而<strong>套接字接口</strong>，<strong>是更为普适的进程间通信机制</strong>，<strong>可用于不同机器之间的进程通信</strong>。</p><p>基于效率考虑，当仅限于本机进程间通讯的时候，套接字接口是被优化过的，不会经过网络协议栈，不需要打包拆包、计算校验和、维护序号和应答等操作，只是简单地将应用层数据从一个进程拷贝至另一个进程，这种进程间通讯方式有个专有的名称 —— Unix Domain Socket，又叫做IPC Socket。</p><blockquote><p><em>套接字（Socket）起初是由 Unix 系统的 BSD 分支开发出来的，但现在已经移植到所有的 Unix 和 Linux 系统上了;</em></p></blockquote><h3 id="2）通信的成本"><a href="#2）通信的成本" class="headerlink" title="2）通信的成本"></a>2）通信的成本</h3><hr><p>计算机科学家们最初的想法，是将 RPC 作为 IPC 的一种特例来看待（其实现在分类上这么说也仍然合适，只是在具体操作手段上不会这么做了）。</p><p>这里，需要特别关注的是最后一种<strong>基于套接字接口的通讯方式</strong>（IPC Socket）。因为它不仅适用于本地相同机器的不同进程间通讯，而且因为 Socket 是网络栈的统一接口，它也理所当然地能支持基于网络的跨机器、跨进程的通讯。</p><blockquote><p><em>比如 Linux 系统的图形化界面中，X Window 服务器和 GUI 程序之间的交互，就是由这套机制来实现的。</em></p></blockquote><p>此外，这样做还有一个看起来无比诱人的好处。因为 <strong>IPC Socket 是操作系统提供的标准接口</strong>，所以它完全有可能把远程方法调用的通讯细节，隐藏在操作系统底层，从应用层面上来看，可以做到远程调用与本地方法调用几乎完全一致。</p><p>事实上，在原始分布式时代的初期确实是奔着这个目标去做的，<strong>但这种透明的调用形式反而让程序员们误以为通信是无成本的，从而被滥用，以至于显著降低了分布式系统的性能。</strong></p><blockquote><p><em>1987 年，当“透明的 RPC 调用”一度成为主流范式的时候，安德鲁 · 塔能鲍姆（Andrew Tanenbaum）教授曾发表了一篇论文“A Critique of the Remote Procedure Call Paradigm”，对这种透明的 RPC 范式提出了一系列质问</em></p><p><em>两个进程通讯，谁作为服务端，谁作为客户端？怎样进行异常处理？异常该如何让调用者获知？服务端出现多线程竞争之后怎么办？如何提高网络利用的效率，比如连接是否可被多个请求复用以减少开销？是否支持多播？参数、返回值如何表示？应该有怎样的字节序？如何保证网络的可靠性，比如调用期间某个链接忽然断开了怎么办？服务端发送请求后，收不到回复该怎么办？……</em></p></blockquote><p>论文的<strong>中心观点</strong>是：把本地调用与远程调用当作一样的来处理，是犯了方向性的错误，把系统间的调用做成透明的，反而会增加程序员工作的复杂度。</p><p>最终，1994 年至 1997 年间，由 ACM 和 Sun 的院士Peter Deutsch、套接字接口发明者Bill Joy、Java 之父James Gosling等众多在 Sun Microsystems 工作的大佬们，<strong>共同总结了通过网络进行分布式运算的八宗罪</strong>（8 Fallacies of Distributed Computing）：</p><ol><li><p>网络是可靠的（The network is reliable）;</p></li><li><p>延迟是不存在的（Latency is zero ）;</p></li><li><p>带宽是无限的（Bandwidth is infinite）;</p></li><li><p>网络是安全的（The network is secure）;</p></li><li><p>拓扑结构是一成不变的（Topology doesn’t change）;</p></li><li><p>总会有一个管理员（There is one administrator）;</p></li><li><p>不考虑传输成本（Transport cost is zero）;</p></li><li><p>网络是同质化的（The network is homogeneous）;</p></li></ol><p>这八宗罪，被认为是程序员在网络编程中经常忽略的八大问题，潜台词就是如果远程服务调用要弄透明化的话，就必须为这些罪过买单。这算是给 RPC 能否等同于 IPC 来实现，<strong>暂时</strong>定下了一个具有公信力的结论。</p><p>到这时为止，<strong>RPC 应该是一种高层次的，或者说语言层次的特征，而不是像 IPC 那样，是低层次的，或者说系统层次的特征</strong>，就成为了工业界、学术界的主流观点。</p><p>到此，可以得出RPC的定义：RPC是一种<strong>语言级别</strong>的通讯协议，它允许运行于一台计算机上的程序以某种管道作为通讯媒介（即某种传输协议的网络），去调用另外一个地址空间（通常为网络上的另一台计算机）。</p><h3 id="3）小结"><a href="#3）小结" class="headerlink" title="3）小结"></a>3）小结</h3><hr><p>这一讲，我们讨论了 RPC 的起源、概念，以及它发展上的一些分歧。以此为基础，我们才能更好地理解后面几讲要学习的内容，包括 RPC 本身要解决的三大问题、RPC 框架的现状与发展，以及它与 REST 的区别。RPC 以模拟进程间方法调用为起点，许多思想和概念都借鉴的是 IPC，因此这一讲我也介绍了 IPC 中的一些关键概念和实现方法。但是，RPC 原本想照着 IPC 的发展思路，却在实现层面上遇到了很大的困难。RPC 作为一种跨网络的通讯手段，能否无视通讯的成本去迁就编程和设计的原则，这一点从几十年前的 DCE 开始，直到今天学术界、工业界都还有争议。</p><h3 id="一课一思"><a href="#一课一思" class="headerlink" title="一课一思"></a>一课一思</h3><hr><p><strong>Q：远程方法不应该无视通讯成本”这个观点，从性能的角度来看是有益的，但从简单的角度看则是有害的。在现代的软件系统开发中，你用过什么 RPC 框架吗？它们有没有把“像本地方法一样调用远程方法”作为卖点？</strong></p><p><img src="https://raw.githubusercontent.com/Tomorrowllbefine/Study/master/pics/image-7.png"></p><blockquote><p><em>– 2024.12.02</em></p></blockquote><h2 id="08-远程服务调用（下）：如何选择适合自己的RPC框架？"><a href="#08-远程服务调用（下）：如何选择适合自己的RPC框架？" class="headerlink" title="08 | 远程服务调用（下）：如何选择适合自己的RPC框架？"></a>08 | 远程服务调用（下）：如何选择适合自己的RPC框架？</h2><hr><h3 id="Topic-01：RPC-框架要解决的三个问题"><a href="#Topic-01：RPC-框架要解决的三个问题" class="headerlink" title="Topic 01：RPC 框架要解决的三个问题"></a>Topic 01：RPC 框架要解决的三个问题</h3><p>RPC 框架要解决的三个问题：</p><ul><li><p>如何表示数据？</p></li><li><p>如何传递数据？</p></li><li><p>如何表示方法？</p></li></ul><h4 id="1）如何表示数据？"><a href="#1）如何表示数据？" class="headerlink" title="1）如何表示数据？"></a>1）如何表示数据？</h4><hr><p>此处的数据含义包括了<strong>传递给方法的参数，以及方法的返回值</strong>。无论是将参数传递给另外一个进程，还是从另外一个进程中取回执行结果，都会涉及<strong>应该如何表示</strong>的问题。</p><ul><li><p><strong>进程内的方法调用</strong>：使用程序语言内置的和程序员自定义的数据类型，可以很容易解决数据表示的问题；</p></li><li><p><strong>远程的方法调用</strong>：可能面临交互双方分属不同程序语言的情况。所以，即使是只支持同一种语言的 RPC 协议，在不同硬件指令集、不同操作系统下，也完全可能有不一样的表现细节，比如数据宽度、字节序的差异等；</p></li></ul><p>行之有效的方法，是<strong>将交互双方涉及的数据，转换为某种事先约定好的中立数据流格式来传输，将数据流转换回不同语言中对应的数据类型来使用</strong>。</p><blockquote><p><em>这个过程说起来比较拗口，但其实就是<strong>序列化</strong>和<strong>反序列化</strong>；</em></p></blockquote><blockquote><p><em>每种 RPC 协议都应该有对应的序列化协议</em></p><ul><li><p><em>ONC RPC 的External Data Representation （XDR）；</em></p></li><li><p><em>CORBA 的Common Data Representation（CDR）；</em></p></li><li><p><em>Java RMI 的Java Object Serialization Stream Protocol；</em></p></li><li><p><em>gRPC 的Protocol Buffers；</em></p></li><li><p><em>Web Service 的XML Serialization；</em></p></li><li><p><em>众多轻量级 RPC 支持的JSON Serialization；</em></p></li></ul></blockquote><h4 id="2）如何传递数据？"><a href="#2）如何传递数据？" class="headerlink" title="2）如何传递数据？"></a>2）如何传递数据？</h4><hr><p>准确地说，如何传递数据是指<strong>如何通过网络，在两个服务 EndPoint 之间相互操作、交换数据</strong>。这里“传递数据”通常指<strong>应用层协议</strong>，一般基于TCP、UDP等传输层协议来完成。</p><p>两个服务交互<strong>不仅仅只是传递一个序列化数据流来表示参数和结果</strong>就行了，诸如异常、超时、安全、认证、授权、事务等信息，都可以存在双方交换信息的需求。</p><p><img src="https://raw.githubusercontent.com/Tomorrowllbefine/Study/master/pics/image-5.png"></p><h4 id="3）如何表示方法？"><a href="#3）如何表示方法？" class="headerlink" title="3）如何表示方法？"></a>3）如何表示方法？</h4><hr><p><strong>本地方法调用</strong>中，由于编译器或者解释器会根据语言规范，把调用的方法转换为进程地址空间中方法入口位置的指针。</p><p>不过一旦考虑到<strong>不同语言</strong>，每门语言的方法签名都可能有所差别，针对 “如何表示一个方法” 和 “如何找到这些方法” 这两个问题，还是得有一个统一的标准。</p><p>这个标准做起来其实可以很简单：<strong>只要给程序中的每个方法，都规定一个通用的又绝对不会重复的编号</strong>；在调用的时候，直接传这个编号就可以找到对应的方法。这种听起来无比寒碜的办法，还真的就是 DCE&#x2F;RPC 最初准备的解决方案。</p><p>虽然最后，DCE 还是弄出了一套跟语言无关的接口描述语言（Interface Description Language，IDL），成为了此后许多 RPC 参考或依赖的基础（如 CORBA 的 OMG IDL），但那个唯一的“绝不重复”的编码方案<strong>UUID</strong>，却意外地流行了起来，已经被广泛应用到了程序开发的方方面面。</p><p><img src="https://raw.githubusercontent.com/Tomorrowllbefine/Study/master/pics/image-1.png"></p><p>如何表示数据、如何传递数据、如何表示方法这三个 RPC 中的基本问题，都可以在本地方法调用中找到对应的操作。</p><p><strong>RPC 的思想始于本地方法调用</strong>，尽管它早就不再追求要跟本地方法调用的实现完全一样，但RPC的发展仍带有着本地方法调用深刻烙印。</p><h3 id="Topic-02：统一的-RPC"><a href="#Topic-02：统一的-RPC" class="headerlink" title="Topic 02：统一的 RPC"></a>Topic 02：统一的 RPC</h3><hr><p>理解了 RPC 要解决的三个基本问题以后，我们接着来看一下，现代的 RPC 框架都为我们提供了哪些可选的解决方案，以及为什么今天会有这么多的 RPC 框架在并行发展。</p><h2 id="09-RESTful服务（上）：从面向过程编程到面向资源编程"><a href="#09-RESTful服务（上）：从面向过程编程到面向资源编程" class="headerlink" title="09 | RESTful服务（上）：从面向过程编程到面向资源编程"></a>09 | RESTful服务（上）：从面向过程编程到面向资源编程</h2><hr><p><img src="https://raw.githubusercontent.com/Tomorrowllbefine/Study/master/pics/image-3.png"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;一、演进中的架构&quot;&gt;&lt;a href=&quot;#一、演进中的架构&quot; class=&quot;headerlink&quot; title=&quot;一、演进中的架构&quot;&gt;&lt;/a&gt;一、演进中的架构&lt;/h1&gt;&lt;h2 id=&quot;01-原始分布式时代：Unix设计哲学下的服务探索&quot;&gt;&lt;a href=&quot;#01-原始分布式时代：Unix设计哲学下的服务探索&quot; class=&quot;headerlink&quot; title=&quot;01 | 原始分布式时代：Unix设计哲学下的服务探索&quot;&gt;&lt;/a&gt;01 | 原始分布式时代：Unix设计哲学下的服务探索&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Tomorrowllbefine/Study/master/pics/image-6.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;就我个人而言，我对”微服务中的简单”的理解，是指微服务中的每个服务，每一个中间件，服务中的每个接口，都是”简单”的，同时也应该以”简单“作为目标进行设计。&lt;/p&gt;
&lt;p&gt;正如很多前辈所言，微服务的出现，目的为了弥补单应用中存在的各个缺陷，如业务功能过多导致代码的耦合度很大，某个功能使用频繁高，占用资源多（本身这个功能可能跟业务无关，但是因为占用大量资源导致整个系统不可用）等等。&lt;/p&gt;</summary>
    
    
    
    
    <category term="read-note" scheme="https://tomorrowllbefine.github.io/tags/read-note/"/>
    
  </entry>
  
  <entry>
    <title>测试</title>
    <link href="https://tomorrowllbefine.github.io/2024/12/20/test/"/>
    <id>https://tomorrowllbefine.github.io/2024/12/20/test/</id>
    <published>2024-12-20T14:52:36.000Z</published>
    <updated>2025-01-10T08:43:56.998Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>嵌入 html：</p></blockquote><div align="center">  <img src="https://raw.githubusercontent.com/Tomorrowllbefine/Study/master/pics/image-20241220173230866.png" alt="image" width="300px"></div>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;嵌入 html：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div align=&quot;center&quot;&gt;
  &lt;img src=&quot;https://raw.githubusercontent.com/Tomorrowllbefine/Study/master/</summary>
      
    
    
    
    
    <category term="test" scheme="https://tomorrowllbefine.github.io/tags/test/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://tomorrowllbefine.github.io/2024/12/20/hello-world/"/>
    <id>https://tomorrowllbefine.github.io/2024/12/20/hello-world/</id>
    <published>2024-12-20T06:42:49.000Z</published>
    <updated>2024-12-20T16:52:18.643Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    <category term="test" scheme="https://tomorrowllbefine.github.io/categories/test/"/>
    
    
    <category term="test" scheme="https://tomorrowllbefine.github.io/tags/test/"/>
    
  </entry>
  
  <entry>
    <title>算法 | 分治</title>
    <link href="https://tomorrowllbefine.github.io/2024/12/20/%E5%88%86%E6%B2%BB%E6%B3%95/"/>
    <id>https://tomorrowllbefine.github.io/2024/12/20/%E5%88%86%E6%B2%BB%E6%B3%95/</id>
    <published>2024-12-20T06:42:49.000Z</published>
    <updated>2024-12-20T16:52:04.908Z</updated>
    
    <content type="html"><![CDATA[<h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><h3 id="Q1：求序列第二大元素"><a href="#Q1：求序列第二大元素" class="headerlink" title="Q1：求序列第二大元素"></a>Q1：求序列第二大元素</h3><p><img src="/Pasted%20image%2020230513151811.png"><br><strong>解</strong>：<br>在分治算法中，当$n&#x3D;2$时，只需要一次比较即可找到第二大元素。当$n&gt;2$时，需要分别在两个子数组中找到第一大和第二大的元素，然后再进行$2$次比较，从而得到整个数组的第二大元素。</p><span id="more"></span><p>假设找到第一大和第二大的元素需要 $T(n)$ 次比较。在分治算法中，我们将数组分成了两个大小为 $n&#x2F;2$ 的子数组，因此我们需要分别在这两个子数组中找到第一大和第二大的元素。由于递归地进行该算法，所以需要进行两次比较。因此，总共需要进行 $2T(n&#x2F;2) + 2$ 次比较。</p><p>当 $n&#x3D;2^k$ 时，递归的深度为 $k$，此时数组中的元素个数为 $2^k$。因此，比较的次数为：</p><p>$$<br>\begin{aligned}<br>T(n) &amp;&#x3D; 2T(n&#x2F;2) + 2 \<br>&amp;&#x3D; 2(2T(n&#x2F;4) + 2) + 2 \<br>&amp;&#x3D; 2^2 T(n&#x2F;2^2) + 2^2 + 2 \<br>&amp;\quad \vdots \<br>&amp;&#x3D; 2^k T(1) + 2^k - 2 \<br>&amp;&#x3D; n - 2 + \frac{n}{2} \<br>&amp;&#x3D; \frac{3n}{2} - 2<br>\end{aligned}<br>$$</p><p>因此，当 $n&#x3D;2^k$ 时，该算法的比较次数为 $3n&#x2F;2 - 2$，选项 $\mathbf{D}$ 是正确的。</p><h3 id="Q2：主定理运用"><a href="#Q2：主定理运用" class="headerlink" title="Q2：主定理运用"></a>Q2：主定理运用</h3><p><img src="/Pasted%20image%2020230513153733.png"><br><strong>解</strong>：<br>该问题中的分治算法的时间复杂度由分治的步骤和治的步骤两部分组成。在分治的步骤中，问题被分成多个规模较小的子问题；在治的步骤中，对每个子问题进行处理。<br><img src="/Pasted%20image%2020230513153853.png" alt="500"><br>在选项 A 中，问题每步被分成 4 个规模均为 n&#x2F;2 的子问题，这是一种类似于四分的方式。在治的步骤中，处理每个子问题的时间复杂度是 Θ(n)。因此，总时间复杂度可以用递归式表示为：**T(n) &#x3D; 4T(n&#x2F;2) + Θ(n)**。 根据主定理，这个递归式的解是 Θ(n^2)。因此，选项 A 的时间复杂度是 Θ(n^2)。</p><p>在选项 B 中，问题每步被分成 2 个规模均为 n&#x2F;2 的子问题，这是一种类似于二分的方式。在治的步骤中，处理每个子问题的时间复杂度是 Θ(n^2)。因此，总时间复杂度可以用递归式表示为：**T(n) &#x3D; 2T(n&#x2F;2) + Θ(n^2)**。 根据主定理，这个递归式的解是 Θ(n^2 log n)。因此，选项 B 的时间复杂度是 Θ(n^2 log n)。</p><p>在选项 C 中，问题每步被分成 7 个规模均为 n&#x2F;3 的子问题。在治的步骤中，处理每个子问题的时间复杂度是 Θ(n)。因此，总时间复杂度可以用递归式表示为：**T(n) &#x3D; 7T(n&#x2F;3) + Θ(n)**。 根据主定理，这个递归式的解是 Θ(n^log3 7)。因此，选项 C 的时间复杂度是 Θ(n^1.77)。</p><p>在选项 D 中，问题每步被分成 5 个规模均为 n&#x2F;3 的子问题。在治的步骤中，处理每个子问题的时间复杂度是 Θ(n^2)。因此，总时间复杂度可以用递归式表示为：**T(n) &#x3D; 5T(n&#x2F;3) + Θ(n^2)*<em>。根据主定理，这个递归式的解是 Θ(n^2</em> log3 5) ≈ Θ(1.464 * n^2)。因此，选项 D 的时间复杂度最快，是 Θ(n^1.464)。</p><p>因此，选项 D 是最快的。</p><h3 id="Q3"><a href="#Q3" class="headerlink" title="Q3"></a>Q3</h3><p><img src="/Pasted%20image%2020230513214506.png"><br><strong>解</strong>：<br>当输入数组 A[1…n]由相等的 n 个元素组成时，快速排序算法 QUICKSORT 的运算特征如下：</p><p>A. 运行时间为 Θ(n log n)。在最坏情况下，每次划分只能减少一个元素，递推式为 T(n) &#x3D; T(n-1) + Θ(n)，解得 T(n) &#x3D; Θ(n^2)；但是，在平均情况下，每次划分可以将序列分为两部分，递推式为 T(n) &#x3D; 2T(n&#x2F;2) + Θ(n)，解得 T(n) &#x3D; Θ(n log n)。</p><p>B. 元素交换次数为 Θ(n)，因为在每次划分结束后，枢轴元素会被放置到其最终位置上，而其他元素都会被分到枢轴元素的左边或右边，因此只需要进行一次交换。</p><p>C. 元素比较次数为 Θ(n log n)，因为在每次划分中，每个元素最多只会与一个枢轴元素进行比较，而划分的次数为 O(log n)，因此总的比较次数为 Θ(n log n)。</p><p>D. 当输入数组 A[1…n]由相等的 n 个元素组成时，每次执行划分过程 SPLIT 后划分出的子序列中有可能存在一个为空。例如，假设枢轴元素取第一个元素，输入数组为 A&#x3D;{1, 1, 1, …, 1}，则在第一次划分后，所有元素都被划分到了右侧子序列中，左侧子序列为空。</p><p>因此，选项 A、B、C 均为正确的，选项 D 不正确。</p><h3 id="Q4："><a href="#Q4：" class="headerlink" title="Q4："></a>Q4：</h3><p><img src="/Pasted%20image%2020230513215034.png"><br><strong>解</strong>：<br>当输入数组 A[1…n]由相等的 n 个元素组成时，快速排序算法 QUICKSORT 的运行特征是每次划分都会将枢轴元素放置在其最终位置上，并将小于（或等于）枢轴元素的元素分到枢轴元素的左边，大于枢轴元素的元素分到枢轴元素的右边。因此，在一个序列中，如果所有元素都相等，则每次划分后，枢轴元素左侧和右侧的子序列都不包含任何元素。由于左侧子序列为空，故枢轴元素必然为该子序列的第一个元素，即为 A[1]。而对于右侧子序列，由于其中也不存在任何元素，因此可以认为其不存在，因此 A[2], A[3], …, A[n]的顺序可以随意排列。</p><p>因此，选项 A 为正确答案，选项 B、C、D 均不正确。</p><h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><h2 id="QuickSort"><a href="#QuickSort" class="headerlink" title="QuickSort"></a>QuickSort</h2><blockquote><p>具体步骤解析见 P112-p115</p></blockquote><h3 id="Split-算法"><a href="#Split-算法" class="headerlink" title="Split 算法"></a>Split 算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回最终a[low]在序列中的下标</span></span><br><span class="line"><span class="comment">//左闭右闭</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">split</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> low, <span class="type">int</span> high )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> i = low; <span class="comment">// 主元素</span></span><br><span class="line"><span class="type">int</span> x = a[low];</span><br><span class="line"><span class="keyword">for</span>( <span class="type">int</span> j = low + <span class="number">1</span>; j &lt;= high; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a[j] &lt;= x)&#123; <span class="comment">//发现小于x的元素</span></span><br><span class="line">i++;</span><br><span class="line"><span class="keyword">if</span>(i!=j) <span class="built_in">swap</span>(a[j], a[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">swap</span>(a[low],a[i]);</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度分析：</p><ul><li>时间复杂度：$O(n)$；</li><li>空间复杂度：$O(1)$；</li></ul><h3 id="主算法"><a href="#主算法" class="headerlink" title="主算法"></a>主算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//左闭右闭</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> low, <span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(low&lt;high)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> pivot = <span class="built_in">split</span>(a,low,high); <span class="comment">//排序后当前主元素所在的下标</span></span><br><span class="line"><span class="comment">//递归调用左右两部分，直至当前区间只有一个元素</span></span><br><span class="line"><span class="built_in">QuickSort</span>(a, low, pivot<span class="number">-1</span>);</span><br><span class="line"><span class="built_in">QuickSort</span>(a, pivot<span class="number">+1</span>, high);</span><br><span class="line">&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">快速排序</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以low为主元素，将序列元素划分为两部分 [ &lt;=a[low], a[low], &gt;a[low] ]</span></span><br><span class="line"><span class="comment">//返回最终a[low]在序列中的下标</span></span><br><span class="line"><span class="comment">//左闭右闭</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">split</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> low, <span class="type">int</span> high )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> i = low; <span class="comment">// 主元素</span></span><br><span class="line"><span class="type">int</span> x = a[low];</span><br><span class="line"><span class="keyword">for</span>( <span class="type">int</span> j = low + <span class="number">1</span>; j &lt;= high; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a[j] &lt;= x)&#123; <span class="comment">//发现小于x的元素</span></span><br><span class="line">i++;</span><br><span class="line"><span class="keyword">if</span>(i!=j) <span class="built_in">swap</span>(a[j], a[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">swap</span>(a[low],a[i]);</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//左闭右闭</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> low, <span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(low&lt;high)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> pivot = <span class="built_in">split</span>(a,low,high); <span class="comment">//排序后当前主元素所在的下标</span></span><br><span class="line"><span class="built_in">QuickSort</span>(a, low, pivot<span class="number">-1</span>);</span><br><span class="line"><span class="built_in">QuickSort</span>(a, pivot<span class="number">+1</span>, high);</span><br><span class="line">&#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a[<span class="number">9</span>] = &#123;<span class="number">0</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="built_in">QuickSort</span>(a,<span class="number">1</span>,<span class="number">8</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i&lt;=<span class="number">8</span>;i++) cout&lt;&lt;a[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><strong>时间复杂度</strong>：$O(nlogn)$<br>最坏情况下：每一轮 split 得到的位置都为 low，即 pivot &#x3D; low，那么每一轮的两次分治都有其一支是没有用的，因此主函数的复杂度为 $O(n)$，综合起来最坏情况下的时间复杂度为$O(n^2)$；<br>最优情况下，每一轮 split 得到的位置为中项的位置，时间复杂度为$O(nlogn)$；</li><li><strong>空间复杂度</strong>：$O(n)$</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;练习&quot;&gt;&lt;a href=&quot;#练习&quot; class=&quot;headerlink&quot; title=&quot;练习&quot;&gt;&lt;/a&gt;练习&lt;/h1&gt;&lt;h3 id=&quot;Q1：求序列第二大元素&quot;&gt;&lt;a href=&quot;#Q1：求序列第二大元素&quot; class=&quot;headerlink&quot; title=&quot;Q1：求序列第二大元素&quot;&gt;&lt;/a&gt;Q1：求序列第二大元素&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/Pasted%20image%2020230513151811.png&quot;&gt;&lt;br&gt;&lt;strong&gt;解&lt;/strong&gt;：&lt;br&gt;在分治算法中，当$n&amp;#x3D;2$时，只需要一次比较即可找到第二大元素。当$n&amp;gt;2$时，需要分别在两个子数组中找到第一大和第二大的元素，然后再进行$2$次比较，从而得到整个数组的第二大元素。&lt;/p&gt;</summary>
    
    
    
    <category term="Algorithm" scheme="https://tomorrowllbefine.github.io/categories/Algorithm/"/>
    
    
    <category term="Algorithm" scheme="https://tomorrowllbefine.github.io/tags/Algorithm/"/>
    
    <category term="分治" scheme="https://tomorrowllbefine.github.io/tags/%E5%88%86%E6%B2%BB/"/>
    
  </entry>
  
</feed>
